
build/stm32-chibios.elf:     file format elf32-littlearm

SYMBOL TABLE:
08000000 l    d  startup	00000000 startup
080000c0 l    d  .text	00000000 .text
20000000 l    d  .stacks	00000000 .stacks
20000800 l    d  .bss	00000000 .bss
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_macro	00000000 .debug_macro
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 vectors.c
00000000 l    df *ABS*	00000000 main.c
080001f0 l     F .text	00000030 Thread2
08000220 l     F .text	00000034 Thread1
20000800 l     O .bss	00000150 waThread1
20000950 l     O .bss	00000150 waThread2
00000000 l    df *ABS*	00000000 _udivsi3.o
08000144 l       .text	00000000 .udivsi3_skip_div0_test
00000000 l    df *ABS*	00000000 _dvmd_tls.o
00000000 l    df *ABS*	00000000 crt0.c
00000000 l    df *ABS*	00000000 chschd.c
080003a0 l     F .text	00000054 wakeup
00000000 l    df *ABS*	00000000 chsys.c
20000abc l     O .bss	00000048 mainthread.4755
00000000 l    df *ABS*	00000000 chthreads.c
00000000 l    df *ABS*	00000000 chvt.c
00000000 l    df *ABS*	00000000 hal.c
00000000 l    df *ABS*	00000000 i2c.c
00000000 l    df *ABS*	00000000 serial.c
08000880 l     F .text	0000000a readt
08000890 l     F .text	0000000e read
080008a0 l     F .text	0000000a writet
080008b0 l     F .text	0000000e write
080008c0 l     F .text	0000000a gett
080008d0 l     F .text	0000000e get
080008e0 l     F .text	0000000a putt
080008f0 l     F .text	0000000e put
08001620 l     O .text	00000020 vmt
00000000 l    df *ABS*	00000000 hal_lld.c
00000000 l    df *ABS*	00000000 i2c_lld.c
00000000 l    df *ABS*	00000000 pal_lld.c
00000000 l    df *ABS*	00000000 serial_lld.c
08000df0 l     F .text	00000010 notify1
08001640 l     O .text	00000010 default_config
00000000 l    df *ABS*	00000000 stm32_dma.c
20000cac l     O .bss	00000028 dma_isr_redir
20000cd4 l     O .bss	00000004 dma_streams_mask
00000000 l    df *ABS*	00000000 board.c
00000000 l    df *ABS*	00000000 chcore_v6m.c
080010c4 l       .text	00000000 _port_exit_from_isr
00000000 l    df *ABS*	00000000 nvic.c
00000000 l    df *ABS*	00000000 chevents.c
00000000 l    df *ABS*	00000000 chheap.c
20000cd8 l     O .bss	00000020 default_heap
00000000 l    df *ABS*	00000000 chlists.c
00000000 l    df *ABS*	00000000 chmemcore.c
20000cf8 l     O .bss	00000004 endmem
20000cfc l     O .bss	00000004 nextmem
00000000 l    df *ABS*	00000000 chmtx.c
00000000 l    df *ABS*	00000000 chqueues.c
08001360 l     F .text	00000028 qwait
00000000 l    df *ABS*	00000000 chregistry.c
00000000 l    df *ABS*	00000000 
08001738 l       .stacks	00000000 _etext
00002000 l       *ABS*	00000000 __ram_size__
00000000 l       startup	00000000 _text
20000000 l       startup	00000000 __ram_start__
20002000 l       *ABS*	00000000 __ram_end__
20000d00 l       .bss	00000000 _end
00000400 l       *ABS*	00000000 __main_stack_size__
00000400 l       *ABS*	00000000 __process_stack_size__
08001690 g     O .text	0000008c pal_default_config
08000390  w    F .text	00000002 Vector58
08000ad0 g     F .text	0000015c Vector9C
080011a0 g     F .text	00000044 nvicEnableVector
08000e00 g     F .text	000000d8 VectorAC
08000790 g     F .text	0000000a chThdExit
08000640 g     F .text	00000058 chSysTimerHandlerI
08001260 g     F .text	00000022 chEvtBroadcastFlagsI
08000470 g     F .text	00000040 chSchGoSleepTimeoutS
08000850 g     F .text	00000008 i2cInit
08000390  w    F .text	00000002 Vector5C
080010e0 g     F .text	0000000e NMIVector
08001050 g     F .text	00000050 dmaInit
08000390  w    F .text	00000002 Vector8C
08000000 g     O startup	000000c0 _vectors
08000440 g     F .text	00000024 chSchGoSleepS
20000bf8 g     O .bss	00000038 I2CD1
20000d00 g       .bss	00000000 __heap_base__
080004b0 g     F .text	00000050 chSchWakeupS
08000970 g     F .text	0000003c sdIncomingDataI
08001520 g     F .text	00000044 chOQGetI
08000400 g     F .text	00000014 _scheduler_init
080006e0 g     F .text	00000060 chThdCreateStatic
08000390  w    F .text	00000002 Vector94
08000390  w    F .text	00000002 VectorA8
08000390  w    F .text	00000002 VectorB4
08000420 g     F .text	00000020 chSchReadyI
080000c0 g       startup	00000000 __fini_array_end
20000800 g       .stacks	00000000 __main_thread_stack_end__
080007a0 g     F .text	00000018 _vt_init
08000140 g     F .text	00000088 .hidden __udivsi3
08001290 g     F .text	00000020 _heap_init
08000390  w    F .text	00000002 Vector74
08000830 g     F .text	00000020 halInit
20000800 g       .bss	00000000 _bss_start
08000500 g     F .text	0000003c chSchDoRescheduleBehind
08000390  w    F .text	00000002 UsageFaultVector
20002000 g       *ABS*	00000000 __heap_end__
08000390  w    F .text	00000002 DebugMonitorVector
08000390  w    F .text	00000002 Vector40
080012b0 g     F .text	0000000c queue_insert
08000280 g     F .text	0000010c ResetHandler
08001440 g     F .text	0000006e chIQReadTimeout
08000390  w    F .text	00000002 VectorBC
080009b0 g     F .text	0000008c hal_lld_init
08000750 g     F .text	00000040 chThdExitS
08000390  w    F .text	00000002 PendSVVector
080007c0 g     F .text	00000038 chVTSetI
08000f80 g     F .text	0000002c Vector64
20000d00 g       .bss	00000000 _bss_end
08000270  w    F .text	00000002 _default_exit
08000d20 g     F .text	000000c2 _pal_lld_setgroupmode
08000ee0 g     F .text	00000028 sd_lld_init
08000390  w    F .text	00000002 Vector54
08000390  w    F .text	00000002 Vector98
08000390  w    F .text	00000002 Vector24
08000580 g     F .text	0000001c chSchDoReschedule
080005c0 g     F .text	00000074 chSysInit
08000740 g     F .text	00000010 chThdSleep
08001390 g     F .text	0000001c chIQInit
08001650 g     O .text	0000003c _stm32_dma_streams
08000390  w    F .text	00000002 Vector84
08001150 g     F .text	00000014 SysTickVector
08000a40 g     F .text	0000008c stm32_clock_init
08000c60 g     F .text	000000c0 _pal_lld_init
08000900 g     F .text	00000008 sdInit
08000390  w    F .text	00000002 BusFaultVector
080012f0 g     F .text	00000028 _core_init
08000950 g     F .text	00000012 sdStart
08001170 g     F .text	00000020 _port_switch
08000390  w    F .text	00000002 SVCallVector
08000260  w    F .text	00000002 __late_init
20000be8 g     O .bss	00000010 vtlist
08000390  w    F .text	00000002 HardFaultVector
080010f0 g     F .text	0000005c _port_irq_epilogue
08001320 g     F .text	0000002c chCoreAlloc
080001e0  w    F .text	00000002 .hidden __aeabi_ldiv0
08001738 g       .stacks	00000000 _textdata
08000390  w    F .text	00000002 MemManageVector
080000c0 g       startup	00000000 __fini_array_start
080000c0 g     F .text	0000007c main
08001000 g     F .text	00000048 Vector6C
20000aa0 g     O .bss	0000001c rlist
08000390  w    F .text	00000002 VectorA0
08000140 g     F .text	00000000 .hidden __aeabi_uidiv
080000c0 g       startup	00000000 __init_array_end
08000390  w    F .text	00000002 Vector7C
08001350 g     F .text	0000000a chMtxInit
080005a0 g     F .text	00000014 _idle_thread
08001570 g     F .text	00000078 chOQWriteTimeout
08000390  w    F .text	00000002 VectorB0
08001720 g     O .text	00000016 ch_debug
08000390  w    F .text	00000002 Vector90
08001220 g     F .text	00000036 chEvtSignalI
08001190 g     F .text	0000000c _port_thread_start
08000390  w    F .text	00000002 Vector60
08000390  w    F .text	00000002 Vector1C
08000540 g     F .text	00000038 chSchDoRescheduleAhead
08000390  w    F .text	00000002 Vector48
08000c30 g     F .text	00000028 i2c_lld_init
20000400 g       .stacks	00000000 __process_stack_base__
08000390  w    F .text	00000002 Vector70
080011f0 g     F .text	00000028 nvicSetSystemHandlerPriority
08000860 g     F .text	00000012 i2cObjectInit
20000b08 g     O .bss	000000e0 _idle_thread_wa
080014b0 g     F .text	00000018 chOQInit
08001400 g     F .text	0000003e chIQGetTimeout
20000800 g       .bss	00000000 _data
080012c0 g     F .text	0000000c fifo_remove
08000390  w    F .text	00000002 Vector4C
08000390  w    F .text	00000002 Vector80
080013b0 g     F .text	0000004e chIQPutI
080010c0 g     F .text	00000014 _port_switch_from_isr
08000fb0 g     F .text	00000048 Vector68
20000400 g       .stacks	00000000 __main_stack_end__
080001c8 g     F .text	00000012 .hidden __aeabi_uidivmod
08000390  w    F .text	00000002 Vector78
080012d0 g     F .text	0000000c dequeue
20000800 g       .bss	00000000 _edata
08000800 g     F .text	00000024 chVTResetI
08000390 g     F .text	00000002 _unhandled_exception
08000910 g     F .text	00000040 sdObjectInit
08000390  w    F .text	00000002 Vector88
20000400 g       .stacks	00000000 __main_thread_stack_base__
080001e0  w    F .text	00000002 .hidden __aeabi_idiv0
080000c0 g       startup	00000000 __init_array_start
20000c30 g     O .bss	0000007c SD1
080006a0 g     F .text	0000003c _thread_init
08000390  w    F .text	00000002 Vector50
080014d0 g     F .text	0000004a chOQPutTimeout
20000000 g       .stacks	00000000 __main_stack_base__
08000390  w    F .text	00000002 Vector44
08000390  w    F .text	00000002 Vector28
080010b0 g     F .text	00000002 boardInit
08000390  w    F .text	00000002 VectorB8
08000f10 g     F .text	0000006c sd_lld_start
20000800 g       .stacks	00000000 __process_stack_end__
080012e0 g     F .text	0000000a list_remove
08000390  w    F .text	00000002 Vector34
080010a0 g     F .text	00000008 __early_init
08000390  w    F .text	00000002 VectorA4
08000390  w    F .text	00000002 Vector20



Disassembly of section .text:

080000c0 <main>:
}

/*
 * Application entry point.
 */
int main(void) {
 80000c0:	b530      	push	{r4, r5, lr}
 80000c2:	b083      	sub	sp, #12
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 80000c4:	f000 fbb4 	bl	8000830 <halInit>
  /*
   * Activates the serial driver 1 using the driver default configuration.
   * PA9 and PA10 are routed to USART1.
   */
  sdStart(&SD1, NULL);
  palSetPadMode(GPIOA, 9, PAL_MODE_ALTERNATE(1));       /* USART1 TX.       */
 80000c8:	2480      	movs	r4, #128	; 0x80
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
  chSysInit();
 80000ca:	f000 fa79 	bl	80005c0 <chSysInit>

  /*
   * Activates the serial driver 1 using the driver default configuration.
   * PA9 and PA10 are routed to USART1.
   */
  sdStart(&SD1, NULL);
 80000ce:	4815      	ldr	r0, [pc, #84]	; (8000124 <__fini_array_end+0x64>)
 80000d0:	2100      	movs	r1, #0
 80000d2:	f000 fc3d 	bl	8000950 <sdStart>
  palSetPadMode(GPIOA, 9, PAL_MODE_ALTERNATE(1));       /* USART1 TX.       */
 80000d6:	00a4      	lsls	r4, r4, #2
 80000d8:	2090      	movs	r0, #144	; 0x90
 80000da:	05c0      	lsls	r0, r0, #23
 80000dc:	1c21      	adds	r1, r4, #0
 80000de:	2282      	movs	r2, #130	; 0x82
 80000e0:	f000 fe1e 	bl	8000d20 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOA, 10, PAL_MODE_ALTERNATE(1));      /* USART1 RX.       */
 80000e4:	2090      	movs	r0, #144	; 0x90
 80000e6:	2180      	movs	r1, #128	; 0x80
 80000e8:	05c0      	lsls	r0, r0, #23
 80000ea:	00c9      	lsls	r1, r1, #3
 80000ec:	2282      	movs	r2, #130	; 0x82
 80000ee:	f000 fe17 	bl	8000d20 <_pal_lld_setgroupmode>

  /*
   * Creates the blinker threads.
   */
	chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 80000f2:	2500      	movs	r5, #0
 80000f4:	21a8      	movs	r1, #168	; 0xa8
 80000f6:	0049      	lsls	r1, r1, #1
 80000f8:	2240      	movs	r2, #64	; 0x40
 80000fa:	4b0b      	ldr	r3, [pc, #44]	; (8000128 <__fini_array_end+0x68>)
 80000fc:	9500      	str	r5, [sp, #0]
 80000fe:	480b      	ldr	r0, [pc, #44]	; (800012c <__fini_array_end+0x6c>)
 8000100:	f000 faee 	bl	80006e0 <chThdCreateStatic>
	chThdCreateStatic(waThread2, sizeof(waThread2), NORMALPRIO, Thread2, NULL);
 8000104:	21a8      	movs	r1, #168	; 0xa8
 8000106:	4b0a      	ldr	r3, [pc, #40]	; (8000130 <__fini_array_end+0x70>)
 8000108:	9500      	str	r5, [sp, #0]
 800010a:	480a      	ldr	r0, [pc, #40]	; (8000134 <__fini_array_end+0x74>)
 800010c:	0049      	lsls	r1, r1, #1
 800010e:	2240      	movs	r2, #64	; 0x40
 8000110:	f000 fae6 	bl	80006e0 <chThdCreateStatic>

	palSetPad(GPIOC, GPIOC_LED3);
 8000114:	4b08      	ldr	r3, [pc, #32]	; (8000138 <__fini_array_end+0x78>)
 8000116:	831c      	strh	r4, [r3, #24]
   * driver 1.
   */
  while (TRUE) {
//    if (palReadPad(GPIOA, GPIOA_BUTTON))
//      TestThread(&SD1);
	chThdSleepMilliseconds(500);
 8000118:	20fa      	movs	r0, #250	; 0xfa
 800011a:	0040      	lsls	r0, r0, #1
 800011c:	f000 fb10 	bl	8000740 <chThdSleep>
 8000120:	e7fa      	b.n	8000118 <main+0x58>
 8000122:	46c0      	nop			; (mov r8, r8)
 8000124:	20000c30 	.word	0x20000c30
 8000128:	08000221 	.word	0x08000221
 800012c:	20000800 	.word	0x20000800
 8000130:	080001f1 	.word	0x080001f1
 8000134:	20000950 	.word	0x20000950
 8000138:	48000800 	.word	0x48000800
 800013c:	46c0      	nop			; (mov r8, r8)
 800013e:	46c0      	nop			; (mov r8, r8)

08000140 <__aeabi_uidiv>:
 8000140:	2900      	cmp	r1, #0
 8000142:	d034      	beq.n	80001ae <.udivsi3_skip_div0_test+0x6a>

08000144 <.udivsi3_skip_div0_test>:
 8000144:	2301      	movs	r3, #1
 8000146:	2200      	movs	r2, #0
 8000148:	b410      	push	{r4}
 800014a:	4288      	cmp	r0, r1
 800014c:	d32c      	bcc.n	80001a8 <.udivsi3_skip_div0_test+0x64>
 800014e:	2401      	movs	r4, #1
 8000150:	0724      	lsls	r4, r4, #28
 8000152:	42a1      	cmp	r1, r4
 8000154:	d204      	bcs.n	8000160 <.udivsi3_skip_div0_test+0x1c>
 8000156:	4281      	cmp	r1, r0
 8000158:	d202      	bcs.n	8000160 <.udivsi3_skip_div0_test+0x1c>
 800015a:	0109      	lsls	r1, r1, #4
 800015c:	011b      	lsls	r3, r3, #4
 800015e:	e7f8      	b.n	8000152 <.udivsi3_skip_div0_test+0xe>
 8000160:	00e4      	lsls	r4, r4, #3
 8000162:	42a1      	cmp	r1, r4
 8000164:	d204      	bcs.n	8000170 <.udivsi3_skip_div0_test+0x2c>
 8000166:	4281      	cmp	r1, r0
 8000168:	d202      	bcs.n	8000170 <.udivsi3_skip_div0_test+0x2c>
 800016a:	0049      	lsls	r1, r1, #1
 800016c:	005b      	lsls	r3, r3, #1
 800016e:	e7f8      	b.n	8000162 <.udivsi3_skip_div0_test+0x1e>
 8000170:	4288      	cmp	r0, r1
 8000172:	d301      	bcc.n	8000178 <.udivsi3_skip_div0_test+0x34>
 8000174:	1a40      	subs	r0, r0, r1
 8000176:	431a      	orrs	r2, r3
 8000178:	084c      	lsrs	r4, r1, #1
 800017a:	42a0      	cmp	r0, r4
 800017c:	d302      	bcc.n	8000184 <.udivsi3_skip_div0_test+0x40>
 800017e:	1b00      	subs	r0, r0, r4
 8000180:	085c      	lsrs	r4, r3, #1
 8000182:	4322      	orrs	r2, r4
 8000184:	088c      	lsrs	r4, r1, #2
 8000186:	42a0      	cmp	r0, r4
 8000188:	d302      	bcc.n	8000190 <.udivsi3_skip_div0_test+0x4c>
 800018a:	1b00      	subs	r0, r0, r4
 800018c:	089c      	lsrs	r4, r3, #2
 800018e:	4322      	orrs	r2, r4
 8000190:	08cc      	lsrs	r4, r1, #3
 8000192:	42a0      	cmp	r0, r4
 8000194:	d302      	bcc.n	800019c <.udivsi3_skip_div0_test+0x58>
 8000196:	1b00      	subs	r0, r0, r4
 8000198:	08dc      	lsrs	r4, r3, #3
 800019a:	4322      	orrs	r2, r4
 800019c:	2800      	cmp	r0, #0
 800019e:	d003      	beq.n	80001a8 <.udivsi3_skip_div0_test+0x64>
 80001a0:	091b      	lsrs	r3, r3, #4
 80001a2:	d001      	beq.n	80001a8 <.udivsi3_skip_div0_test+0x64>
 80001a4:	0909      	lsrs	r1, r1, #4
 80001a6:	e7e3      	b.n	8000170 <.udivsi3_skip_div0_test+0x2c>
 80001a8:	1c10      	adds	r0, r2, #0
 80001aa:	bc10      	pop	{r4}
 80001ac:	4770      	bx	lr
 80001ae:	2800      	cmp	r0, #0
 80001b0:	d001      	beq.n	80001b6 <.udivsi3_skip_div0_test+0x72>
 80001b2:	2000      	movs	r0, #0
 80001b4:	43c0      	mvns	r0, r0
 80001b6:	b407      	push	{r0, r1, r2}
 80001b8:	4802      	ldr	r0, [pc, #8]	; (80001c4 <.udivsi3_skip_div0_test+0x80>)
 80001ba:	a102      	add	r1, pc, #8	; (adr r1, 80001c4 <.udivsi3_skip_div0_test+0x80>)
 80001bc:	1840      	adds	r0, r0, r1
 80001be:	9002      	str	r0, [sp, #8]
 80001c0:	bd03      	pop	{r0, r1, pc}
 80001c2:	46c0      	nop			; (mov r8, r8)
 80001c4:	0000001d 	.word	0x0000001d

080001c8 <__aeabi_uidivmod>:
 80001c8:	2900      	cmp	r1, #0
 80001ca:	d0f0      	beq.n	80001ae <.udivsi3_skip_div0_test+0x6a>
 80001cc:	b503      	push	{r0, r1, lr}
 80001ce:	f7ff ffb9 	bl	8000144 <.udivsi3_skip_div0_test>
 80001d2:	bc0e      	pop	{r1, r2, r3}
 80001d4:	4342      	muls	r2, r0
 80001d6:	1a89      	subs	r1, r1, r2
 80001d8:	4718      	bx	r3
 80001da:	46c0      	nop			; (mov r8, r8)
 80001dc:	0000      	movs	r0, r0
	...

080001e0 <__aeabi_idiv0>:
 80001e0:	4770      	bx	lr
 80001e2:	46c0      	nop			; (mov r8, r8)
	...

080001f0 <Thread2>:
 */
static WORKING_AREA(waThread2, 128);
static msg_t Thread2(void *arg) {

  (void)arg;
  chRegSetThreadName("blinker2");
 80001f0:	4b08      	ldr	r3, [pc, #32]	; (8000214 <Thread2+0x24>)

/*
 * Green LED blinker thread, times are in milliseconds.
 */
static WORKING_AREA(waThread2, 128);
static msg_t Thread2(void *arg) {
 80001f2:	b570      	push	{r4, r5, r6, lr}

  (void)arg;
  chRegSetThreadName("blinker2");
 80001f4:	699b      	ldr	r3, [r3, #24]
 80001f6:	4a08      	ldr	r2, [pc, #32]	; (8000218 <Thread2+0x28>)
  while (TRUE) {
    palClearPad(GPIOC, GPIOC_LED3);
 80001f8:	2580      	movs	r5, #128	; 0x80
 80001fa:	00ad      	lsls	r5, r5, #2
 80001fc:	4c07      	ldr	r4, [pc, #28]	; (800021c <Thread2+0x2c>)
 */
static WORKING_AREA(waThread2, 128);
static msg_t Thread2(void *arg) {

  (void)arg;
  chRegSetThreadName("blinker2");
 80001fe:	619a      	str	r2, [r3, #24]
  while (TRUE) {
    palClearPad(GPIOC, GPIOC_LED3);
 8000200:	1c2e      	adds	r6, r5, #0
 8000202:	8366      	strh	r6, [r4, #26]
    chThdSleepMilliseconds(250);
 8000204:	20fa      	movs	r0, #250	; 0xfa
 8000206:	f000 fa9b 	bl	8000740 <chThdSleep>
    palSetPad(GPIOC, GPIOC_LED3);
 800020a:	8325      	strh	r5, [r4, #24]
    chThdSleepMilliseconds(250);
 800020c:	20fa      	movs	r0, #250	; 0xfa
 800020e:	f000 fa97 	bl	8000740 <chThdSleep>
 8000212:	e7f6      	b.n	8000202 <Thread2+0x12>
 8000214:	20000aa0 	.word	0x20000aa0
 8000218:	080015f0 	.word	0x080015f0
 800021c:	48000800 	.word	0x48000800

08000220 <Thread1>:
 */
static WORKING_AREA(waThread1, 128);
static msg_t Thread1(void *arg) {

  (void)arg;
  chRegSetThreadName("blinker1");
 8000220:	4b09      	ldr	r3, [pc, #36]	; (8000248 <Thread1+0x28>)

/*
 * Blue LED blinker thread, times are in milliseconds.
 */
static WORKING_AREA(waThread1, 128);
static msg_t Thread1(void *arg) {
 8000222:	b570      	push	{r4, r5, r6, lr}

  (void)arg;
  chRegSetThreadName("blinker1");
 8000224:	699b      	ldr	r3, [r3, #24]
 8000226:	4a09      	ldr	r2, [pc, #36]	; (800024c <Thread1+0x2c>)
  while (TRUE) {
    palClearPad(GPIOC, GPIOC_LED4);
 8000228:	2580      	movs	r5, #128	; 0x80
 800022a:	006d      	lsls	r5, r5, #1
 800022c:	4c08      	ldr	r4, [pc, #32]	; (8000250 <Thread1+0x30>)
 */
static WORKING_AREA(waThread1, 128);
static msg_t Thread1(void *arg) {

  (void)arg;
  chRegSetThreadName("blinker1");
 800022e:	619a      	str	r2, [r3, #24]
  while (TRUE) {
    palClearPad(GPIOC, GPIOC_LED4);
 8000230:	1c2e      	adds	r6, r5, #0
    chThdSleepMilliseconds(500);
 8000232:	20fa      	movs	r0, #250	; 0xfa
static msg_t Thread1(void *arg) {

  (void)arg;
  chRegSetThreadName("blinker1");
  while (TRUE) {
    palClearPad(GPIOC, GPIOC_LED4);
 8000234:	8366      	strh	r6, [r4, #26]
    chThdSleepMilliseconds(500);
 8000236:	0040      	lsls	r0, r0, #1
 8000238:	f000 fa82 	bl	8000740 <chThdSleep>
    palSetPad(GPIOC, GPIOC_LED4);
    chThdSleepMilliseconds(500);
 800023c:	20fa      	movs	r0, #250	; 0xfa
  (void)arg;
  chRegSetThreadName("blinker1");
  while (TRUE) {
    palClearPad(GPIOC, GPIOC_LED4);
    chThdSleepMilliseconds(500);
    palSetPad(GPIOC, GPIOC_LED4);
 800023e:	8325      	strh	r5, [r4, #24]
    chThdSleepMilliseconds(500);
 8000240:	0040      	lsls	r0, r0, #1
 8000242:	f000 fa7d 	bl	8000740 <chThdSleep>
 8000246:	e7f4      	b.n	8000232 <Thread1+0x12>
 8000248:	20000aa0 	.word	0x20000aa0
 800024c:	080015fc 	.word	0x080015fc
 8000250:	48000800 	.word	0x48000800
 8000254:	46c0      	nop			; (mov r8, r8)
 8000256:	46c0      	nop			; (mov r8, r8)
 8000258:	46c0      	nop			; (mov r8, r8)
 800025a:	46c0      	nop			; (mov r8, r8)
 800025c:	46c0      	nop			; (mov r8, r8)
 800025e:	46c0      	nop			; (mov r8, r8)

08000260 <__late_init>:
 * @note    This function is a weak symbol.
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
void __late_init(void) {}
 8000260:	4770      	bx	lr
 8000262:	46c0      	nop			; (mov r8, r8)
 8000264:	46c0      	nop			; (mov r8, r8)
 8000266:	46c0      	nop			; (mov r8, r8)
 8000268:	46c0      	nop			; (mov r8, r8)
 800026a:	46c0      	nop			; (mov r8, r8)
 800026c:	46c0      	nop			; (mov r8, r8)
 800026e:	46c0      	nop			; (mov r8, r8)

08000270 <_default_exit>:
 * @note    This function is a weak symbol.
 */
#if !defined(__DOXYGEN__)
__attribute__((weak, naked))
#endif
void _default_exit(void) {
 8000270:	e7fe      	b.n	8000270 <_default_exit>
 8000272:	46c0      	nop			; (mov r8, r8)
 8000274:	46c0      	nop			; (mov r8, r8)
 8000276:	46c0      	nop			; (mov r8, r8)
 8000278:	46c0      	nop			; (mov r8, r8)
 800027a:	46c0      	nop			; (mov r8, r8)
 800027c:	46c0      	nop			; (mov r8, r8)
 800027e:	46c0      	nop			; (mov r8, r8)

08000280 <ResetHandler>:
  uint32_t psp, reg;

  /* Process Stack initialization, it is allocated starting from the
     symbol __process_stack_end__ and its lower limit is the symbol
     __process_stack_base__.*/
  asm volatile ("cpsid   i");
 8000280:	b672      	cpsid	i
  psp = SYMVAL(__process_stack_end__);
 8000282:	4834      	ldr	r0, [pc, #208]	; (8000354 <ResetHandler+0xd4>)
 8000284:	1c05      	adds	r5, r0, #0
  asm volatile ("msr     PSP, %0" : : "r" (psp));
 8000286:	f380 8809 	msr	PSP, r0
  reg = CRT0_CONTROL_INIT | 4;
#else
  /* CPU mode initialization.*/
  reg = CRT0_CONTROL_INIT;
#endif
  asm volatile ("msr     CONTROL, %0" : : "r" (reg));
 800028a:	2302      	movs	r3, #2
 800028c:	f383 8814 	msr	CONTROL, r3
  asm volatile ("isb");
 8000290:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_STACKS
  /* Main and Process stacks initialization.*/
  fill32(&__main_stack_base__,
 8000294:	4b30      	ldr	r3, [pc, #192]	; (8000358 <ResetHandler+0xd8>)
 8000296:	4a31      	ldr	r2, [pc, #196]	; (800035c <ResetHandler+0xdc>)
 8000298:	4293      	cmp	r3, r2
 800029a:	d209      	bcs.n	80002b0 <ResetHandler+0x30>
 800029c:	1d1c      	adds	r4, r3, #4
 800029e:	1cd1      	adds	r1, r2, #3
 80002a0:	1b09      	subs	r1, r1, r4
 80002a2:	0889      	lsrs	r1, r1, #2
 80002a4:	0089      	lsls	r1, r1, #2
 80002a6:	4a2e      	ldr	r2, [pc, #184]	; (8000360 <ResetHandler+0xe0>)
 80002a8:	1861      	adds	r1, r4, r1
 80002aa:	c304      	stmia	r3!, {r2}
 80002ac:	428b      	cmp	r3, r1
 80002ae:	d1fc      	bne.n	80002aa <ResetHandler+0x2a>
         &__main_stack_end__,
         CRT0_STACKS_FILL_PATTERN);
  fill32(&__process_stack_base__,
 80002b0:	4b2c      	ldr	r3, [pc, #176]	; (8000364 <ResetHandler+0xe4>)
 80002b2:	4283      	cmp	r3, r0
 80002b4:	d209      	bcs.n	80002ca <ResetHandler+0x4a>
 80002b6:	1d1a      	adds	r2, r3, #4
 80002b8:	1ce9      	adds	r1, r5, #3
 80002ba:	1a89      	subs	r1, r1, r2
 80002bc:	0889      	lsrs	r1, r1, #2
 80002be:	0089      	lsls	r1, r1, #2
 80002c0:	1851      	adds	r1, r2, r1
 80002c2:	4a27      	ldr	r2, [pc, #156]	; (8000360 <ResetHandler+0xe0>)
 80002c4:	c304      	stmia	r3!, {r2}
 80002c6:	428b      	cmp	r3, r1
 80002c8:	d1fc      	bne.n	80002c4 <ResetHandler+0x44>
         &__process_stack_end__,
         CRT0_STACKS_FILL_PATTERN);
#endif

  /* Early initialization hook invocation.*/
  __early_init();
 80002ca:	f000 fee9 	bl	80010a0 <__early_init>
  {
    uint32_t *tp, *dp;

    tp = &_textdata;
    dp = &_data;
    while (dp < &_edata)
 80002ce:	4a26      	ldr	r2, [pc, #152]	; (8000368 <ResetHandler+0xe8>)
 80002d0:	4b26      	ldr	r3, [pc, #152]	; (800036c <ResetHandler+0xec>)
 80002d2:	429a      	cmp	r2, r3
 80002d4:	d20b      	bcs.n	80002ee <ResetHandler+0x6e>
 80002d6:	43d0      	mvns	r0, r2
 80002d8:	18c0      	adds	r0, r0, r3
 80002da:	0880      	lsrs	r0, r0, #2
 80002dc:	3001      	adds	r0, #1
 80002de:	4924      	ldr	r1, [pc, #144]	; (8000370 <ResetHandler+0xf0>)
 80002e0:	0080      	lsls	r0, r0, #2
 80002e2:	2300      	movs	r3, #0
      *dp++ = *tp++;
 80002e4:	58cc      	ldr	r4, [r1, r3]
 80002e6:	50d4      	str	r4, [r2, r3]
 80002e8:	3304      	adds	r3, #4
  {
    uint32_t *tp, *dp;

    tp = &_textdata;
    dp = &_data;
    while (dp < &_edata)
 80002ea:	4283      	cmp	r3, r0
 80002ec:	d1fa      	bne.n	80002e4 <ResetHandler+0x64>
  }
#endif

#if CRT0_INIT_BSS
  /* BSS segment initialization.*/
  fill32(&_bss_start, &_bss_end, 0);
 80002ee:	4b21      	ldr	r3, [pc, #132]	; (8000374 <ResetHandler+0xf4>)
 80002f0:	4a21      	ldr	r2, [pc, #132]	; (8000378 <ResetHandler+0xf8>)
 80002f2:	4293      	cmp	r3, r2
 80002f4:	d209      	bcs.n	800030a <ResetHandler+0x8a>
 80002f6:	1d18      	adds	r0, r3, #4
 80002f8:	1cd1      	adds	r1, r2, #3
 80002fa:	1a09      	subs	r1, r1, r0
 80002fc:	0889      	lsrs	r1, r1, #2
 80002fe:	0089      	lsls	r1, r1, #2
 8000300:	1841      	adds	r1, r0, r1
 8000302:	2200      	movs	r2, #0
 8000304:	c304      	stmia	r3!, {r2}
 8000306:	428b      	cmp	r3, r1
 8000308:	d1fc      	bne.n	8000304 <ResetHandler+0x84>
#endif

  /* Late initialization hook invocation.*/
  __late_init();
 800030a:	f7ff ffa9 	bl	8000260 <__late_init>

#if CRT0_CALL_CONSTRUCTORS
  /* Constructors invocation.*/
  {
    funcpp_t fpp = &__init_array_start;
    while (fpp < &__init_array_end) {
 800030e:	4d1b      	ldr	r5, [pc, #108]	; (800037c <ResetHandler+0xfc>)
 8000310:	4b1b      	ldr	r3, [pc, #108]	; (8000380 <ResetHandler+0x100>)
 8000312:	429d      	cmp	r5, r3
 8000314:	d20a      	bcs.n	800032c <ResetHandler+0xac>
 8000316:	43ee      	mvns	r6, r5
 8000318:	18f6      	adds	r6, r6, r3
 800031a:	08b6      	lsrs	r6, r6, #2
 800031c:	3601      	adds	r6, #1
 800031e:	2400      	movs	r4, #0
 8000320:	00a3      	lsls	r3, r4, #2
      (*fpp)();
 8000322:	58eb      	ldr	r3, [r5, r3]
 8000324:	3401      	adds	r4, #1
 8000326:	4798      	blx	r3

#if CRT0_CALL_CONSTRUCTORS
  /* Constructors invocation.*/
  {
    funcpp_t fpp = &__init_array_start;
    while (fpp < &__init_array_end) {
 8000328:	42b4      	cmp	r4, r6
 800032a:	d1f9      	bne.n	8000320 <ResetHandler+0xa0>
    }
  }
#endif

  /* Invoking application main() function.*/
  main();
 800032c:	f7ff fec8 	bl	80000c0 <main>

#if CRT0_CALL_DESTRUCTORS
  /* Destructors invocation.*/
  {
    funcpp_t fpp = &__fini_array_start;
    while (fpp < &__fini_array_end) {
 8000330:	4d14      	ldr	r5, [pc, #80]	; (8000384 <ResetHandler+0x104>)
 8000332:	4b15      	ldr	r3, [pc, #84]	; (8000388 <ResetHandler+0x108>)
 8000334:	429d      	cmp	r5, r3
 8000336:	d20a      	bcs.n	800034e <ResetHandler+0xce>
 8000338:	43ee      	mvns	r6, r5
 800033a:	18f6      	adds	r6, r6, r3
 800033c:	08b6      	lsrs	r6, r6, #2
 800033e:	3601      	adds	r6, #1
 8000340:	2400      	movs	r4, #0
 8000342:	00a3      	lsls	r3, r4, #2
      (*fpp)();
 8000344:	58eb      	ldr	r3, [r5, r3]
 8000346:	3401      	adds	r4, #1
 8000348:	4798      	blx	r3

#if CRT0_CALL_DESTRUCTORS
  /* Destructors invocation.*/
  {
    funcpp_t fpp = &__fini_array_start;
    while (fpp < &__fini_array_end) {
 800034a:	42b4      	cmp	r4, r6
 800034c:	d1f9      	bne.n	8000342 <ResetHandler+0xc2>
    }
  }
#endif

  /* Invoking the exit handler.*/
  _default_exit();
 800034e:	f7ff ff8f 	bl	8000270 <_default_exit>
 8000352:	46c0      	nop			; (mov r8, r8)
 8000354:	20000800 	.word	0x20000800
 8000358:	20000000 	.word	0x20000000
 800035c:	20000400 	.word	0x20000400
 8000360:	55555555 	.word	0x55555555
 8000364:	20000400 	.word	0x20000400
 8000368:	20000800 	.word	0x20000800
 800036c:	20000800 	.word	0x20000800
 8000370:	08001738 	.word	0x08001738
 8000374:	20000800 	.word	0x20000800
 8000378:	20000d00 	.word	0x20000d00
 800037c:	080000c0 	.word	0x080000c0
 8000380:	080000c0 	.word	0x080000c0
 8000384:	080000c0 	.word	0x080000c0
 8000388:	080000c0 	.word	0x080000c0
 800038c:	46c0      	nop			; (mov r8, r8)
 800038e:	46c0      	nop			; (mov r8, r8)

08000390 <_unhandled_exception>:
 * @notapi
 */
#if !defined(__DOXYGEN__)
__attribute__ ((naked))
#endif
void _unhandled_exception(void) {
 8000390:	e7fe      	b.n	8000390 <_unhandled_exception>
 8000392:	46c0      	nop			; (mov r8, r8)
 8000394:	46c0      	nop			; (mov r8, r8)
 8000396:	46c0      	nop			; (mov r8, r8)
 8000398:	46c0      	nop			; (mov r8, r8)
 800039a:	46c0      	nop			; (mov r8, r8)
 800039c:	46c0      	nop			; (mov r8, r8)
 800039e:	46c0      	nop			; (mov r8, r8)

080003a0 <wakeup>:

#if !defined(PORT_OPTIMIZED_GOSLEEPTIMEOUTS) || defined(__DOXYGEN__)
/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 80003a0:	b510      	push	{r4, lr}
 80003a2:	1c04      	adds	r4, r0, #0
  Thread *tp = (Thread *)p;

  chSysLockFromIsr();
 80003a4:	b672      	cpsid	i
  switch (tp->p_state) {
 80003a6:	7f03      	ldrb	r3, [r0, #28]
 80003a8:	2b03      	cmp	r3, #3
 80003aa:	d019      	beq.n	80003e0 <wakeup+0x40>
 80003ac:	d914      	bls.n	80003d8 <wakeup+0x38>
 80003ae:	2b05      	cmp	r3, #5
 80003b0:	d01a      	beq.n	80003e8 <wakeup+0x48>
 80003b2:	2b0d      	cmp	r3, #13
 80003b4:	d018      	beq.n	80003e8 <wakeup+0x48>
#endif
    /* States requiring dequeuing.*/
    dequeue(tp);
#endif
  }
  tp->p_u.rdymsg = RDY_TIMEOUT;
 80003b6:	2301      	movs	r3, #1
 80003b8:	425b      	negs	r3, r3
 80003ba:	6263      	str	r3, [r4, #36]	; 0x24
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
 80003bc:	2300      	movs	r3, #0
 80003be:	7723      	strb	r3, [r4, #28]
 80003c0:	68a2      	ldr	r2, [r4, #8]
  cp = (Thread *)&rlist.r_queue;
 80003c2:	4b0b      	ldr	r3, [pc, #44]	; (80003f0 <wakeup+0x50>)
  do {
    cp = cp->p_next;
 80003c4:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 80003c6:	6899      	ldr	r1, [r3, #8]
 80003c8:	4291      	cmp	r1, r2
 80003ca:	d2fb      	bcs.n	80003c4 <wakeup+0x24>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80003cc:	685a      	ldr	r2, [r3, #4]
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 80003ce:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
 80003d0:	6062      	str	r2, [r4, #4]
  tp->p_prev->p_next = cp->p_prev = tp;
 80003d2:	605c      	str	r4, [r3, #4]
 80003d4:	6014      	str	r4, [r2, #0]
 80003d6:	e001      	b.n	80003dc <wakeup+0x3c>
 */
static void wakeup(void *p) {
  Thread *tp = (Thread *)p;

  chSysLockFromIsr();
  switch (tp->p_state) {
 80003d8:	2b00      	cmp	r3, #0
 80003da:	d1ec      	bne.n	80003b6 <wakeup+0x16>
    dequeue(tp);
#endif
  }
  tp->p_u.rdymsg = RDY_TIMEOUT;
  chSchReadyI(tp);
  chSysUnlockFromIsr();
 80003dc:	b662      	cpsie	i
}
 80003de:	bd10      	pop	{r4, pc}
    return;
#if CH_USE_SEMAPHORES || CH_USE_QUEUES ||                                   \
    (CH_USE_CONDVARS && CH_USE_CONDVARS_TIMEOUT)
#if CH_USE_SEMAPHORES
  case THD_STATE_WTSEM:
    chSemFastSignalI((Semaphore *)tp->p_u.wtobjp);
 80003e0:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80003e2:	689a      	ldr	r2, [r3, #8]
 80003e4:	3201      	adds	r2, #1
 80003e6:	609a      	str	r2, [r3, #8]
#endif
#if CH_USE_CONDVARS && CH_USE_CONDVARS_TIMEOUT
  case THD_STATE_WTCOND:
#endif
    /* States requiring dequeuing.*/
    dequeue(tp);
 80003e8:	1c20      	adds	r0, r4, #0
 80003ea:	f000 ff71 	bl	80012d0 <dequeue>
 80003ee:	e7e2      	b.n	80003b6 <wakeup+0x16>
 80003f0:	20000aa0 	.word	0x20000aa0
 80003f4:	46c0      	nop			; (mov r8, r8)
 80003f6:	46c0      	nop			; (mov r8, r8)
 80003f8:	46c0      	nop			; (mov r8, r8)
 80003fa:	46c0      	nop			; (mov r8, r8)
 80003fc:	46c0      	nop			; (mov r8, r8)
 80003fe:	46c0      	nop			; (mov r8, r8)

08000400 <_scheduler_init>:
 *
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&rlist.r_queue);
 8000400:	4b03      	ldr	r3, [pc, #12]	; (8000410 <_scheduler_init+0x10>)
  rlist.r_prio = NOPRIO;
 8000402:	2200      	movs	r2, #0
 *
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&rlist.r_queue);
 8000404:	605b      	str	r3, [r3, #4]
 8000406:	601b      	str	r3, [r3, #0]
  rlist.r_prio = NOPRIO;
 8000408:	609a      	str	r2, [r3, #8]
#if CH_USE_REGISTRY
  rlist.r_newer = rlist.r_older = (Thread *)&rlist;
 800040a:	615b      	str	r3, [r3, #20]
 800040c:	611b      	str	r3, [r3, #16]
#endif
}
 800040e:	4770      	bx	lr
 8000410:	20000aa0 	.word	0x20000aa0
 8000414:	46c0      	nop			; (mov r8, r8)
 8000416:	46c0      	nop			; (mov r8, r8)
 8000418:	46c0      	nop			; (mov r8, r8)
 800041a:	46c0      	nop			; (mov r8, r8)
 800041c:	46c0      	nop			; (mov r8, r8)
 800041e:	46c0      	nop			; (mov r8, r8)

08000420 <chSchReadyI>:
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
 8000420:	2300      	movs	r3, #0
 8000422:	7703      	strb	r3, [r0, #28]
 8000424:	6882      	ldr	r2, [r0, #8]
  cp = (Thread *)&rlist.r_queue;
 8000426:	4b05      	ldr	r3, [pc, #20]	; (800043c <chSchReadyI+0x1c>)
  do {
    cp = cp->p_next;
 8000428:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 800042a:	6899      	ldr	r1, [r3, #8]
 800042c:	4291      	cmp	r1, r2
 800042e:	d2fb      	bcs.n	8000428 <chSchReadyI+0x8>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000430:	685a      	ldr	r2, [r3, #4]
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8000432:	6003      	str	r3, [r0, #0]
  tp->p_prev = cp->p_prev;
 8000434:	6042      	str	r2, [r0, #4]
  tp->p_prev->p_next = cp->p_prev = tp;
 8000436:	6058      	str	r0, [r3, #4]
 8000438:	6010      	str	r0, [r2, #0]
  return tp;
}
 800043a:	4770      	bx	lr
 800043c:	20000aa0 	.word	0x20000aa0

08000440 <chSchGoSleepS>:
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_GOSLEEPS) || defined(__DOXYGEN__)
void chSchGoSleepS(tstate_t newstate) {
 8000440:	b538      	push	{r3, r4, r5, lr}
  Thread *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
 8000442:	4d07      	ldr	r5, [pc, #28]	; (8000460 <chSchGoSleepS+0x20>)
#if CH_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_TIME_QUANTUM;
 8000444:	2314      	movs	r3, #20
void chSchGoSleepS(tstate_t newstate) {
  Thread *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
 8000446:	69ac      	ldr	r4, [r5, #24]
 8000448:	7720      	strb	r0, [r4, #28]
#if CH_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_TIME_QUANTUM;
 800044a:	77e3      	strb	r3, [r4, #31]
#endif
  setcurrp(fifo_remove(&rlist.r_queue));
 800044c:	1c28      	adds	r0, r5, #0
 800044e:	f000 ff37 	bl	80012c0 <fifo_remove>
  currp->p_state = THD_STATE_CURRENT;
 8000452:	2301      	movs	r3, #1
 8000454:	7703      	strb	r3, [r0, #28]
  chSysSwitch(currp, otp);
 8000456:	1c21      	adds	r1, r4, #0
#if CH_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_TIME_QUANTUM;
#endif
  setcurrp(fifo_remove(&rlist.r_queue));
 8000458:	61a8      	str	r0, [r5, #24]
  currp->p_state = THD_STATE_CURRENT;
  chSysSwitch(currp, otp);
 800045a:	f000 fe89 	bl	8001170 <_port_switch>
}
 800045e:	bd38      	pop	{r3, r4, r5, pc}
 8000460:	20000aa0 	.word	0x20000aa0
 8000464:	46c0      	nop			; (mov r8, r8)
 8000466:	46c0      	nop			; (mov r8, r8)
 8000468:	46c0      	nop			; (mov r8, r8)
 800046a:	46c0      	nop			; (mov r8, r8)
 800046c:	46c0      	nop			; (mov r8, r8)
 800046e:	46c0      	nop			; (mov r8, r8)

08000470 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval RDY_TIMEOUT if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000470:	b530      	push	{r4, r5, lr}
 8000472:	1c05      	adds	r5, r0, #0
 8000474:	b087      	sub	sp, #28

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8000476:	1c4b      	adds	r3, r1, #1
 8000478:	d012      	beq.n	80004a0 <chSchGoSleepTimeoutS+0x30>
    VirtualTimer vt;

    chVTSetI(&vt, time, wakeup, currp);
 800047a:	4c0b      	ldr	r4, [pc, #44]	; (80004a8 <chSchGoSleepTimeoutS+0x38>)
 800047c:	a801      	add	r0, sp, #4
 800047e:	69a3      	ldr	r3, [r4, #24]
 8000480:	4a0a      	ldr	r2, [pc, #40]	; (80004ac <chSchGoSleepTimeoutS+0x3c>)
 8000482:	f000 f99d 	bl	80007c0 <chVTSetI>
    chSchGoSleepS(newstate);
 8000486:	1c28      	adds	r0, r5, #0
 8000488:	f7ff ffda 	bl	8000440 <chSchGoSleepS>
    if (chVTIsArmedI(&vt))
 800048c:	9b04      	ldr	r3, [sp, #16]
 800048e:	2b00      	cmp	r3, #0
 8000490:	d002      	beq.n	8000498 <chSchGoSleepTimeoutS+0x28>
      chVTResetI(&vt);
 8000492:	a801      	add	r0, sp, #4
 8000494:	f000 f9b4 	bl	8000800 <chVTResetI>
  }
  else
    chSchGoSleepS(newstate);
  return currp->p_u.rdymsg;
 8000498:	69a3      	ldr	r3, [r4, #24]
 800049a:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
 800049c:	b007      	add	sp, #28
 800049e:	bd30      	pop	{r4, r5, pc}
    chSchGoSleepS(newstate);
    if (chVTIsArmedI(&vt))
      chVTResetI(&vt);
  }
  else
    chSchGoSleepS(newstate);
 80004a0:	f7ff ffce 	bl	8000440 <chSchGoSleepS>
 80004a4:	4c00      	ldr	r4, [pc, #0]	; (80004a8 <chSchGoSleepTimeoutS+0x38>)
 80004a6:	e7f7      	b.n	8000498 <chSchGoSleepTimeoutS+0x28>
 80004a8:	20000aa0 	.word	0x20000aa0
 80004ac:	080003a1 	.word	0x080003a1

080004b0 <chSchWakeupS>:
 * @param[in] msg       message to the awakened thread
 *
 * @sclass
 */
#if !defined(PORT_OPTIMIZED_WAKEUPS) || defined(__DOXYGEN__)
void chSchWakeupS(Thread *ntp, msg_t msg) {
 80004b0:	b538      	push	{r3, r4, r5, lr}
  ntp->p_u.rdymsg = msg;
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
 80004b2:	4d12      	ldr	r5, [pc, #72]	; (80004fc <chSchWakeupS+0x4c>)
#if !defined(PORT_OPTIMIZED_WAKEUPS) || defined(__DOXYGEN__)
void chSchWakeupS(Thread *ntp, msg_t msg) {

  chDbgCheckClassS();

  ntp->p_u.rdymsg = msg;
 80004b4:	6241      	str	r1, [r0, #36]	; 0x24
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
 80004b6:	69a9      	ldr	r1, [r5, #24]
 80004b8:	6884      	ldr	r4, [r0, #8]
 80004ba:	688a      	ldr	r2, [r1, #8]
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
 80004bc:	2300      	movs	r3, #0
  ntp->p_u.rdymsg = msg;
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
 80004be:	4294      	cmp	r4, r2
 80004c0:	d80b      	bhi.n	80004da <chSchWakeupS+0x2a>
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
 80004c2:	7703      	strb	r3, [r0, #28]
  cp = (Thread *)&rlist.r_queue;
 80004c4:	1c2b      	adds	r3, r5, #0
  do {
    cp = cp->p_next;
 80004c6:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 80004c8:	689a      	ldr	r2, [r3, #8]
 80004ca:	4294      	cmp	r4, r2
 80004cc:	d9fb      	bls.n	80004c6 <chSchWakeupS+0x16>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80004ce:	685a      	ldr	r2, [r3, #4]
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 80004d0:	6003      	str	r3, [r0, #0]
  tp->p_prev = cp->p_prev;
 80004d2:	6042      	str	r2, [r0, #4]
  tp->p_prev->p_next = cp->p_prev = tp;
 80004d4:	6058      	str	r0, [r3, #4]
 80004d6:	6010      	str	r0, [r2, #0]
    Thread *otp = chSchReadyI(currp);
    setcurrp(ntp);
    ntp->p_state = THD_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 80004d8:	bd38      	pop	{r3, r4, r5, pc}
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
 80004da:	770b      	strb	r3, [r1, #28]
  cp = (Thread *)&rlist.r_queue;
 80004dc:	1c2b      	adds	r3, r5, #0
  do {
    cp = cp->p_next;
 80004de:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 80004e0:	689c      	ldr	r4, [r3, #8]
 80004e2:	42a2      	cmp	r2, r4
 80004e4:	d9fb      	bls.n	80004de <chSchWakeupS+0x2e>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80004e6:	685a      	ldr	r2, [r3, #4]
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 80004e8:	600b      	str	r3, [r1, #0]
  tp->p_prev = cp->p_prev;
 80004ea:	604a      	str	r2, [r1, #4]
  tp->p_prev->p_next = cp->p_prev = tp;
 80004ec:	6059      	str	r1, [r3, #4]
  if (ntp->p_prio <= currp->p_prio)
    chSchReadyI(ntp);
  else {
    Thread *otp = chSchReadyI(currp);
    setcurrp(ntp);
    ntp->p_state = THD_STATE_CURRENT;
 80004ee:	2301      	movs	r3, #1
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 80004f0:	6011      	str	r1, [r2, #0]
  if (ntp->p_prio <= currp->p_prio)
    chSchReadyI(ntp);
  else {
    Thread *otp = chSchReadyI(currp);
    setcurrp(ntp);
    ntp->p_state = THD_STATE_CURRENT;
 80004f2:	7703      	strb	r3, [r0, #28]
     list instead.*/
  if (ntp->p_prio <= currp->p_prio)
    chSchReadyI(ntp);
  else {
    Thread *otp = chSchReadyI(currp);
    setcurrp(ntp);
 80004f4:	61a8      	str	r0, [r5, #24]
    ntp->p_state = THD_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 80004f6:	f000 fe3b 	bl	8001170 <_port_switch>
 80004fa:	e7ed      	b.n	80004d8 <chSchWakeupS+0x28>
 80004fc:	20000aa0 	.word	0x20000aa0

08000500 <chSchDoRescheduleBehind>:
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEBEHIND) || defined(__DOXYGEN__)
void chSchDoRescheduleBehind(void) {
 8000500:	b538      	push	{r3, r4, r5, lr}
  Thread *otp;

  otp = currp;
 8000502:	4d0d      	ldr	r5, [pc, #52]	; (8000538 <chSchDoRescheduleBehind+0x38>)
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
 8000504:	1c28      	adds	r0, r5, #0
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEBEHIND) || defined(__DOXYGEN__)
void chSchDoRescheduleBehind(void) {
  Thread *otp;

  otp = currp;
 8000506:	69ac      	ldr	r4, [r5, #24]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
 8000508:	f000 feda 	bl	80012c0 <fifo_remove>
  currp->p_state = THD_STATE_CURRENT;
 800050c:	2301      	movs	r3, #1
 800050e:	7703      	strb	r3, [r0, #28]
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
 8000510:	2314      	movs	r3, #20
 8000512:	77e3      	strb	r3, [r4, #31]
 8000514:	68a2      	ldr	r2, [r4, #8]
  chDbgAssert((tp->p_state != THD_STATE_READY) &&
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
 8000516:	2300      	movs	r3, #0
 8000518:	7723      	strb	r3, [r4, #28]
void chSchDoRescheduleBehind(void) {
  Thread *otp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
 800051a:	61a8      	str	r0, [r5, #24]
              (tp->p_state != THD_STATE_FINAL),
              "chSchReadyI(), #1",
              "invalid state");

  tp->p_state = THD_STATE_READY;
  cp = (Thread *)&rlist.r_queue;
 800051c:	1c2b      	adds	r3, r5, #0
  do {
    cp = cp->p_next;
 800051e:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 8000520:	6899      	ldr	r1, [r3, #8]
 8000522:	4291      	cmp	r1, r2
 8000524:	d2fb      	bcs.n	800051e <chSchDoRescheduleBehind+0x1e>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000526:	685a      	ldr	r2, [r3, #4]
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8000528:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
 800052a:	6062      	str	r2, [r4, #4]
  currp->p_state = THD_STATE_CURRENT;
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
#endif
  chSchReadyI(otp);
  chSysSwitch(currp, otp);
 800052c:	1c21      	adds	r1, r4, #0
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 800052e:	605c      	str	r4, [r3, #4]
 8000530:	6014      	str	r4, [r2, #0]
  currp->p_state = THD_STATE_CURRENT;
#if CH_TIME_QUANTUM > 0
  otp->p_preempt = CH_TIME_QUANTUM;
#endif
  chSchReadyI(otp);
  chSysSwitch(currp, otp);
 8000532:	f000 fe1d 	bl	8001170 <_port_switch>
}
 8000536:	bd38      	pop	{r3, r4, r5, pc}
 8000538:	20000aa0 	.word	0x20000aa0
 800053c:	46c0      	nop			; (mov r8, r8)
 800053e:	46c0      	nop			; (mov r8, r8)

08000540 <chSchDoRescheduleAhead>:
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEAHEAD) || defined(__DOXYGEN__)
void chSchDoRescheduleAhead(void) {
 8000540:	b538      	push	{r3, r4, r5, lr}
  Thread *otp, *cp;

  otp = currp;
 8000542:	4d0c      	ldr	r5, [pc, #48]	; (8000574 <chSchDoRescheduleAhead+0x34>)
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
 8000544:	1c28      	adds	r0, r5, #0
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULEAHEAD) || defined(__DOXYGEN__)
void chSchDoRescheduleAhead(void) {
  Thread *otp, *cp;

  otp = currp;
 8000546:	69ac      	ldr	r4, [r5, #24]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
 8000548:	f000 feba 	bl	80012c0 <fifo_remove>
  currp->p_state = THD_STATE_CURRENT;
 800054c:	2301      	movs	r3, #1
 800054e:	7703      	strb	r3, [r0, #28]
 8000550:	68a2      	ldr	r2, [r4, #8]

  otp->p_state = THD_STATE_READY;
 8000552:	2300      	movs	r3, #0
 8000554:	7723      	strb	r3, [r4, #28]
void chSchDoRescheduleAhead(void) {
  Thread *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(fifo_remove(&rlist.r_queue));
 8000556:	61a8      	str	r0, [r5, #24]
  currp->p_state = THD_STATE_CURRENT;

  otp->p_state = THD_STATE_READY;
  cp = (Thread *)&rlist.r_queue;
 8000558:	1c2b      	adds	r3, r5, #0
  do {
    cp = cp->p_next;
 800055a:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio > otp->p_prio);
 800055c:	6899      	ldr	r1, [r3, #8]
 800055e:	4291      	cmp	r1, r2
 8000560:	d8fb      	bhi.n	800055a <chSchDoRescheduleAhead+0x1a>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 8000562:	685a      	ldr	r2, [r3, #4]
  cp = (Thread *)&rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 8000564:	6023      	str	r3, [r4, #0]
  otp->p_prev = cp->p_prev;
 8000566:	6062      	str	r2, [r4, #4]
  otp->p_prev->p_next = cp->p_prev = otp;

  chSysSwitch(currp, otp);
 8000568:	1c21      	adds	r1, r4, #0
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = cp->p_prev = otp;
 800056a:	605c      	str	r4, [r3, #4]
 800056c:	6014      	str	r4, [r2, #0]

  chSysSwitch(currp, otp);
 800056e:	f000 fdff 	bl	8001170 <_port_switch>
}
 8000572:	bd38      	pop	{r3, r4, r5, pc}
 8000574:	20000aa0 	.word	0x20000aa0
 8000578:	46c0      	nop			; (mov r8, r8)
 800057a:	46c0      	nop			; (mov r8, r8)
 800057c:	46c0      	nop			; (mov r8, r8)
 800057e:	46c0      	nop			; (mov r8, r8)

08000580 <chSchDoReschedule>:
 *          itself or from within the port layer.
 *
 * @special
 */
#if !defined(PORT_OPTIMIZED_DORESCHEDULE) || defined(__DOXYGEN__)
void chSchDoReschedule(void) {
 8000580:	b508      	push	{r3, lr}

#if CH_TIME_QUANTUM > 0
  /* If CH_TIME_QUANTUM is enabled then there are two different scenarios to
     handle on preemption: time quantum elapsed or not.*/
  if (currp->p_preempt == 0) {
 8000582:	4b05      	ldr	r3, [pc, #20]	; (8000598 <chSchDoReschedule+0x18>)
 8000584:	699b      	ldr	r3, [r3, #24]
 8000586:	7fdb      	ldrb	r3, [r3, #31]
 8000588:	2b00      	cmp	r3, #0
 800058a:	d002      	beq.n	8000592 <chSchDoReschedule+0x12>
    chSchDoRescheduleBehind();
  }
  else {
    /* The thread didn't consume all its time quantum so it is put ahead of
       threads with equal priority and does not acquire a new time quantum.*/
    chSchDoRescheduleAhead();
 800058c:	f7ff ffd8 	bl	8000540 <chSchDoRescheduleAhead>
#else /* !(CH_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
#endif /* !(CH_TIME_QUANTUM > 0) */
}
 8000590:	bd08      	pop	{r3, pc}
  /* If CH_TIME_QUANTUM is enabled then there are two different scenarios to
     handle on preemption: time quantum elapsed or not.*/
  if (currp->p_preempt == 0) {
    /* The thread consumed its time quantum so it is enqueued behind threads
       with same priority level, however, it acquires a new time quantum.*/
    chSchDoRescheduleBehind();
 8000592:	f7ff ffb5 	bl	8000500 <chSchDoRescheduleBehind>
 8000596:	e7fb      	b.n	8000590 <chSchDoReschedule+0x10>
 8000598:	20000aa0 	.word	0x20000aa0
 800059c:	46c0      	nop			; (mov r8, r8)
 800059e:	46c0      	nop			; (mov r8, r8)

080005a0 <_idle_thread>:
 * @param[in] p the thread parameter, unused in this scenario
 */
void _idle_thread(void *p) {

  (void)p;
  chRegSetThreadName("idle");
 80005a0:	4b02      	ldr	r3, [pc, #8]	; (80005ac <_idle_thread+0xc>)
 80005a2:	4a03      	ldr	r2, [pc, #12]	; (80005b0 <_idle_thread+0x10>)
 80005a4:	699b      	ldr	r3, [r3, #24]
 80005a6:	619a      	str	r2, [r3, #24]
 80005a8:	e7fe      	b.n	80005a8 <_idle_thread+0x8>
 80005aa:	46c0      	nop			; (mov r8, r8)
 80005ac:	20000aa0 	.word	0x20000aa0
 80005b0:	08001610 	.word	0x08001610
 80005b4:	46c0      	nop			; (mov r8, r8)
 80005b6:	46c0      	nop			; (mov r8, r8)
 80005b8:	46c0      	nop			; (mov r8, r8)
 80005ba:	46c0      	nop			; (mov r8, r8)
 80005bc:	46c0      	nop			; (mov r8, r8)
 80005be:	46c0      	nop			; (mov r8, r8)

080005c0 <chSysInit>:
 * @note    This function has special, architecture-dependent, requirements,
 *          see the notes into the various port reference manuals.
 *
 * @special
 */
void chSysInit(void) {
 80005c0:	b500      	push	{lr}
  static Thread mainthread;
#if CH_DBG_ENABLE_STACK_CHECK
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
 80005c2:	4a15      	ldr	r2, [pc, #84]	; (8000618 <chSysInit+0x58>)
 80005c4:	4b15      	ldr	r3, [pc, #84]	; (800061c <chSysInit+0x5c>)
 * @note    This function has special, architecture-dependent, requirements,
 *          see the notes into the various port reference manuals.
 *
 * @special
 */
void chSysInit(void) {
 80005c6:	b083      	sub	sp, #12
  static Thread mainthread;
#if CH_DBG_ENABLE_STACK_CHECK
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
 80005c8:	60da      	str	r2, [r3, #12]
 80005ca:	200a      	movs	r0, #10
 80005cc:	2100      	movs	r1, #0
 80005ce:	f000 fe0f 	bl	80011f0 <nvicSetSystemHandlerPriority>
 80005d2:	200b      	movs	r0, #11
 80005d4:	2180      	movs	r1, #128	; 0x80
 80005d6:	f000 fe0b 	bl	80011f0 <nvicSetSystemHandlerPriority>
  _scheduler_init();
 80005da:	f7ff ff11 	bl	8000400 <_scheduler_init>
  _vt_init();
 80005de:	f000 f8df 	bl	80007a0 <_vt_init>
#if CH_USE_MEMCORE
  _core_init();
 80005e2:	f000 fe85 	bl	80012f0 <_core_init>
#endif
#if CH_USE_HEAP
  _heap_init();
 80005e6:	f000 fe53 	bl	8001290 <_heap_init>
#if CH_DBG_ENABLE_TRACE
  _trace_init();
#endif

  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&mainthread, NORMALPRIO));
 80005ea:	2140      	movs	r1, #64	; 0x40
 80005ec:	480c      	ldr	r0, [pc, #48]	; (8000620 <chSysInit+0x60>)
 80005ee:	f000 f857 	bl	80006a0 <_thread_init>
 80005f2:	4b0c      	ldr	r3, [pc, #48]	; (8000624 <chSysInit+0x64>)
 80005f4:	6198      	str	r0, [r3, #24]
  currp->p_state = THD_STATE_CURRENT;
 80005f6:	2301      	movs	r3, #1
 80005f8:	7703      	strb	r3, [r0, #28]
#if CH_DBG_ENABLE_STACK_CHECK
  /* This is a special case because the main thread Thread structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
#endif
  chSysEnable();
 80005fa:	b662      	cpsie	i

  /* Note, &ch_debug points to the string "main" if the registry is
     active, else the parameter is ignored.*/
  chRegSetThreadName((const char *)&ch_debug);
 80005fc:	4b09      	ldr	r3, [pc, #36]	; (8000624 <chSysInit+0x64>)
 80005fe:	4a0a      	ldr	r2, [pc, #40]	; (8000628 <chSysInit+0x68>)
 8000600:	699b      	ldr	r3, [r3, #24]

#if !CH_NO_IDLE_THREAD
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  chThdCreateStatic(_idle_thread_wa, sizeof(_idle_thread_wa), IDLEPRIO,
 8000602:	21e0      	movs	r1, #224	; 0xe0
#endif
  chSysEnable();

  /* Note, &ch_debug points to the string "main" if the registry is
     active, else the parameter is ignored.*/
  chRegSetThreadName((const char *)&ch_debug);
 8000604:	619a      	str	r2, [r3, #24]

#if !CH_NO_IDLE_THREAD
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  chThdCreateStatic(_idle_thread_wa, sizeof(_idle_thread_wa), IDLEPRIO,
 8000606:	2300      	movs	r3, #0
 8000608:	9300      	str	r3, [sp, #0]
 800060a:	2201      	movs	r2, #1
 800060c:	4b07      	ldr	r3, [pc, #28]	; (800062c <chSysInit+0x6c>)
 800060e:	4808      	ldr	r0, [pc, #32]	; (8000630 <chSysInit+0x70>)
 8000610:	f000 f866 	bl	80006e0 <chThdCreateStatic>
                    (tfunc_t)_idle_thread, NULL);
#endif
}
 8000614:	b003      	add	sp, #12
 8000616:	bd00      	pop	{pc}
 8000618:	05fa0000 	.word	0x05fa0000
 800061c:	e000ed00 	.word	0xe000ed00
 8000620:	20000abc 	.word	0x20000abc
 8000624:	20000aa0 	.word	0x20000aa0
 8000628:	08001720 	.word	0x08001720
 800062c:	080005a1 	.word	0x080005a1
 8000630:	20000b08 	.word	0x20000b08
 8000634:	46c0      	nop			; (mov r8, r8)
 8000636:	46c0      	nop			; (mov r8, r8)
 8000638:	46c0      	nop			; (mov r8, r8)
 800063a:	46c0      	nop			; (mov r8, r8)
 800063c:	46c0      	nop			; (mov r8, r8)
 800063e:	46c0      	nop			; (mov r8, r8)

08000640 <chSysTimerHandlerI>:
 *          and, together with the @p CH_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8000640:	b570      	push	{r4, r5, r6, lr}

  chDbgCheckClassI();

#if CH_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (currp->p_preempt > 0)
 8000642:	4b13      	ldr	r3, [pc, #76]	; (8000690 <chSysTimerHandlerI+0x50>)
 8000644:	699b      	ldr	r3, [r3, #24]
 8000646:	7fda      	ldrb	r2, [r3, #31]
 8000648:	2a00      	cmp	r2, #0
 800064a:	d001      	beq.n	8000650 <chSysTimerHandlerI+0x10>
    /* Decrement remaining quantum.*/
    currp->p_preempt--;
 800064c:	3a01      	subs	r2, #1
 800064e:	77da      	strb	r2, [r3, #31]
#endif
#if CH_DBG_THREADS_PROFILING
  currp->p_time++;
 8000650:	6a1a      	ldr	r2, [r3, #32]
 8000652:	3201      	adds	r2, #1
 8000654:	621a      	str	r2, [r3, #32]
#endif
  chVTDoTickI();
 8000656:	4a0f      	ldr	r2, [pc, #60]	; (8000694 <chSysTimerHandlerI+0x54>)
 8000658:	68d3      	ldr	r3, [r2, #12]
 800065a:	3301      	adds	r3, #1
 800065c:	60d3      	str	r3, [r2, #12]
 800065e:	6813      	ldr	r3, [r2, #0]
 8000660:	4293      	cmp	r3, r2
 8000662:	d014      	beq.n	800068e <chSysTimerHandlerI+0x4e>
 8000664:	6899      	ldr	r1, [r3, #8]
 8000666:	3901      	subs	r1, #1
 8000668:	6099      	str	r1, [r3, #8]
 800066a:	2900      	cmp	r1, #0
 800066c:	d10f      	bne.n	800068e <chSysTimerHandlerI+0x4e>
 800066e:	2600      	movs	r6, #0
 8000670:	1c14      	adds	r4, r2, #0
 8000672:	6819      	ldr	r1, [r3, #0]
 8000674:	68dd      	ldr	r5, [r3, #12]
 8000676:	6011      	str	r1, [r2, #0]
 8000678:	60de      	str	r6, [r3, #12]
 800067a:	604a      	str	r2, [r1, #4]
 800067c:	b662      	cpsie	i
 800067e:	6918      	ldr	r0, [r3, #16]
 8000680:	47a8      	blx	r5
 8000682:	b672      	cpsid	i
 8000684:	6823      	ldr	r3, [r4, #0]
 8000686:	1c22      	adds	r2, r4, #0
 8000688:	6899      	ldr	r1, [r3, #8]
 800068a:	2900      	cmp	r1, #0
 800068c:	d0f1      	beq.n	8000672 <chSysTimerHandlerI+0x32>
#if defined(SYSTEM_TICK_EVENT_HOOK)
  SYSTEM_TICK_EVENT_HOOK();
#endif
}
 800068e:	bd70      	pop	{r4, r5, r6, pc}
 8000690:	20000aa0 	.word	0x20000aa0
 8000694:	20000be8 	.word	0x20000be8
 8000698:	46c0      	nop			; (mov r8, r8)
 800069a:	46c0      	nop			; (mov r8, r8)
 800069c:	46c0      	nop			; (mov r8, r8)
 800069e:	46c0      	nop			; (mov r8, r8)

080006a0 <_thread_init>:
 * @notapi
 */
Thread *_thread_init(Thread *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = THD_STATE_SUSPENDED;
 80006a0:	2302      	movs	r3, #2
 80006a2:	7703      	strb	r3, [r0, #28]
  tp->p_flags = THD_MEM_MODE_STATIC;
 80006a4:	2300      	movs	r3, #0
 80006a6:	7743      	strb	r3, [r0, #29]
#if CH_TIME_QUANTUM > 0
  tp->p_preempt = CH_TIME_QUANTUM;
#endif
#if CH_USE_MUTEXES
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 80006a8:	63c3      	str	r3, [r0, #60]	; 0x3c
#endif
#if CH_USE_EVENTS
  tp->p_epending = 0;
 80006aa:	6383      	str	r3, [r0, #56]	; 0x38
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
 80006ac:	6203      	str	r3, [r0, #32]
#endif
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
 80006ae:	6183      	str	r3, [r0, #24]

  tp->p_prio = prio;
  tp->p_state = THD_STATE_SUSPENDED;
  tp->p_flags = THD_MEM_MODE_STATIC;
#if CH_TIME_QUANTUM > 0
  tp->p_preempt = CH_TIME_QUANTUM;
 80006b0:	2214      	movs	r2, #20
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 80006b2:	4b09      	ldr	r3, [pc, #36]	; (80006d8 <_thread_init+0x38>)

  tp->p_prio = prio;
  tp->p_state = THD_STATE_SUSPENDED;
  tp->p_flags = THD_MEM_MODE_STATIC;
#if CH_TIME_QUANTUM > 0
  tp->p_preempt = CH_TIME_QUANTUM;
 80006b4:	77c2      	strb	r2, [r0, #31]
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
#endif
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
 80006b6:	2201      	movs	r2, #1
 80006b8:	7782      	strb	r2, [r0, #30]
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 80006ba:	695a      	ldr	r2, [r3, #20]
 80006bc:	6103      	str	r3, [r0, #16]
 *
 * @notapi
 */
Thread *_thread_init(Thread *tp, tprio_t prio) {

  tp->p_prio = prio;
 80006be:	6081      	str	r1, [r0, #8]
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 80006c0:	6142      	str	r2, [r0, #20]
 80006c2:	6158      	str	r0, [r3, #20]
#endif
#if CH_USE_WAITEXIT
  list_init(&tp->p_waiting);
 80006c4:	1c03      	adds	r3, r0, #0
 80006c6:	3328      	adds	r3, #40	; 0x28
  tp->p_flags = THD_MEM_MODE_STATIC;
#if CH_TIME_QUANTUM > 0
  tp->p_preempt = CH_TIME_QUANTUM;
#endif
#if CH_USE_MUTEXES
  tp->p_realprio = prio;
 80006c8:	6401      	str	r1, [r0, #64]	; 0x40
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 80006ca:	6110      	str	r0, [r2, #16]
#endif
#if CH_USE_WAITEXIT
  list_init(&tp->p_waiting);
 80006cc:	6283      	str	r3, [r0, #40]	; 0x28
#endif
#if CH_USE_MESSAGES
  queue_init(&tp->p_msgqueue);
 80006ce:	3304      	adds	r3, #4
 80006d0:	6303      	str	r3, [r0, #48]	; 0x30
 80006d2:	62c3      	str	r3, [r0, #44]	; 0x2c
#endif
#if defined(THREAD_EXT_INIT_HOOK)
  THREAD_EXT_INIT_HOOK(tp);
#endif
  return tp;
}
 80006d4:	4770      	bx	lr
 80006d6:	46c0      	nop			; (mov r8, r8)
 80006d8:	20000aa0 	.word	0x20000aa0
 80006dc:	46c0      	nop			; (mov r8, r8)
 80006de:	46c0      	nop			; (mov r8, r8)

080006e0 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
Thread *chThdCreateStatic(void *wsp, size_t size,
                          tprio_t prio, tfunc_t pf, void *arg) {
 80006e0:	b510      	push	{r4, lr}
 80006e2:	1c04      	adds	r4, r0, #0
                  CH_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(Thread),
                  (uint8_t *)wsp + size,
                  CH_STACK_FILL_VALUE);
#endif
  chSysLock();
 80006e4:	b672      	cpsid	i
  chDbgCheckClassI();

  chDbgCheck((wsp != NULL) && (size >= THD_WA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL),
             "chThdCreateI");
  SETUP_CONTEXT(wsp, size, pf, arg);
 80006e6:	3924      	subs	r1, #36	; 0x24
 80006e8:	1841      	adds	r1, r0, r1
 80006ea:	60c1      	str	r1, [r0, #12]
 80006ec:	610b      	str	r3, [r1, #16]
 80006ee:	9b02      	ldr	r3, [sp, #8]
 80006f0:	614b      	str	r3, [r1, #20]
 80006f2:	4b11      	ldr	r3, [pc, #68]	; (8000738 <chThdCreateStatic+0x58>)
 80006f4:	620b      	str	r3, [r1, #32]
 * @notapi
 */
Thread *_thread_init(Thread *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = THD_STATE_SUSPENDED;
 80006f6:	2302      	movs	r3, #2
 80006f8:	7703      	strb	r3, [r0, #28]
  tp->p_flags = THD_MEM_MODE_STATIC;
 80006fa:	2300      	movs	r3, #0
 80006fc:	7743      	strb	r3, [r0, #29]
#if CH_TIME_QUANTUM > 0
  tp->p_preempt = CH_TIME_QUANTUM;
#endif
#if CH_USE_MUTEXES
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 80006fe:	63c3      	str	r3, [r0, #60]	; 0x3c
#endif
#if CH_USE_EVENTS
  tp->p_epending = 0;
 8000700:	6383      	str	r3, [r0, #56]	; 0x38
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
 8000702:	6203      	str	r3, [r0, #32]
#endif
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
 8000704:	6183      	str	r3, [r0, #24]
  REG_INSERT(tp);
 8000706:	4b0d      	ldr	r3, [pc, #52]	; (800073c <chThdCreateStatic+0x5c>)
 *
 * @notapi
 */
Thread *_thread_init(Thread *tp, tprio_t prio) {

  tp->p_prio = prio;
 8000708:	6082      	str	r2, [r0, #8]
  tp->p_flags = THD_MEM_MODE_STATIC;
#if CH_TIME_QUANTUM > 0
  tp->p_preempt = CH_TIME_QUANTUM;
#endif
#if CH_USE_MUTEXES
  tp->p_realprio = prio;
 800070a:	6402      	str	r2, [r0, #64]	; 0x40
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
#endif
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
 800070c:	2201      	movs	r2, #1
 800070e:	7782      	strb	r2, [r0, #30]
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000710:	695a      	ldr	r2, [r3, #20]
 8000712:	6103      	str	r3, [r0, #16]
 8000714:	6142      	str	r2, [r0, #20]
 8000716:	6158      	str	r0, [r3, #20]
#endif
#if CH_USE_WAITEXIT
  list_init(&tp->p_waiting);
 8000718:	1c03      	adds	r3, r0, #0

  tp->p_prio = prio;
  tp->p_state = THD_STATE_SUSPENDED;
  tp->p_flags = THD_MEM_MODE_STATIC;
#if CH_TIME_QUANTUM > 0
  tp->p_preempt = CH_TIME_QUANTUM;
 800071a:	2114      	movs	r1, #20
#if CH_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_USE_WAITEXIT
  list_init(&tp->p_waiting);
 800071c:	3328      	adds	r3, #40	; 0x28

  tp->p_prio = prio;
  tp->p_state = THD_STATE_SUSPENDED;
  tp->p_flags = THD_MEM_MODE_STATIC;
#if CH_TIME_QUANTUM > 0
  tp->p_preempt = CH_TIME_QUANTUM;
 800071e:	77c1      	strb	r1, [r0, #31]
#if CH_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000720:	6110      	str	r0, [r2, #16]
#endif
#if CH_USE_WAITEXIT
  list_init(&tp->p_waiting);
 8000722:	6283      	str	r3, [r0, #40]	; 0x28
#endif
#if CH_USE_MESSAGES
  queue_init(&tp->p_msgqueue);
 8000724:	3304      	adds	r3, #4
 8000726:	6303      	str	r3, [r0, #48]	; 0x30
 8000728:	62c3      	str	r3, [r0, #44]	; 0x2c
  _thread_memfill((uint8_t *)wsp + sizeof(Thread),
                  (uint8_t *)wsp + size,
                  CH_STACK_FILL_VALUE);
#endif
  chSysLock();
  chSchWakeupS(tp = chThdCreateI(wsp, size, prio, pf, arg), RDY_OK);
 800072a:	2100      	movs	r1, #0
 800072c:	f7ff fec0 	bl	80004b0 <chSchWakeupS>
  chSysUnlock();
 8000730:	b662      	cpsie	i
  return tp;
}
 8000732:	1c20      	adds	r0, r4, #0
 8000734:	bd10      	pop	{r4, pc}
 8000736:	46c0      	nop			; (mov r8, r8)
 8000738:	08001191 	.word	0x08001191
 800073c:	20000aa0 	.word	0x20000aa0

08000740 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8000740:	b508      	push	{r3, lr}
 8000742:	1c01      	adds	r1, r0, #0

  chDbgCheck(time != TIME_IMMEDIATE, "chThdSleep");

  chSysLock();
 8000744:	b672      	cpsid	i
  chThdSleepS(time);
 8000746:	2006      	movs	r0, #6
 8000748:	f7ff fe92 	bl	8000470 <chSchGoSleepTimeoutS>
  chSysUnlock();
 800074c:	b662      	cpsie	i
}
 800074e:	bd08      	pop	{r3, pc}

08000750 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8000750:	b538      	push	{r3, r4, r5, lr}
  Thread *tp = currp;
 8000752:	4b0e      	ldr	r3, [pc, #56]	; (800078c <chThdExitS+0x3c>)
 8000754:	699d      	ldr	r5, [r3, #24]
  tp->p_u.exitcode = msg;
#if defined(THREAD_EXT_EXIT_HOOK)
  THREAD_EXT_EXIT_HOOK(tp);
#endif
#if CH_USE_WAITEXIT
  while (notempty(&tp->p_waiting))
 8000756:	1c2c      	adds	r4, r5, #0
 8000758:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 800075a:	3428      	adds	r4, #40	; 0x28
 * @sclass
 */
void chThdExitS(msg_t msg) {
  Thread *tp = currp;

  tp->p_u.exitcode = msg;
 800075c:	6268      	str	r0, [r5, #36]	; 0x24
#if defined(THREAD_EXT_EXIT_HOOK)
  THREAD_EXT_EXIT_HOOK(tp);
#endif
#if CH_USE_WAITEXIT
  while (notempty(&tp->p_waiting))
 800075e:	42a2      	cmp	r2, r4
 8000760:	d007      	beq.n	8000772 <chThdExitS+0x22>
    chSchReadyI(list_remove(&tp->p_waiting));
 8000762:	1c20      	adds	r0, r4, #0
 8000764:	f000 fdbc 	bl	80012e0 <list_remove>
 8000768:	f7ff fe5a 	bl	8000420 <chSchReadyI>
  tp->p_u.exitcode = msg;
#if defined(THREAD_EXT_EXIT_HOOK)
  THREAD_EXT_EXIT_HOOK(tp);
#endif
#if CH_USE_WAITEXIT
  while (notempty(&tp->p_waiting))
 800076c:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800076e:	42a3      	cmp	r3, r4
 8000770:	d1f7      	bne.n	8000762 <chThdExitS+0x12>
    chSchReadyI(list_remove(&tp->p_waiting));
#endif
#if CH_USE_REGISTRY
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & THD_MEM_MODE_MASK) == THD_MEM_MODE_STATIC)
 8000772:	7f6b      	ldrb	r3, [r5, #29]
 8000774:	079a      	lsls	r2, r3, #30
 8000776:	d104      	bne.n	8000782 <chThdExitS+0x32>
    REG_REMOVE(tp);
 8000778:	692a      	ldr	r2, [r5, #16]
 800077a:	696b      	ldr	r3, [r5, #20]
 800077c:	611a      	str	r2, [r3, #16]
 800077e:	692a      	ldr	r2, [r5, #16]
 8000780:	6153      	str	r3, [r2, #20]
#endif
  chSchGoSleepS(THD_STATE_FINAL);
 8000782:	200e      	movs	r0, #14
 8000784:	f7ff fe5c 	bl	8000440 <chSchGoSleepS>
  /* The thread never returns here.*/
  chDbgAssert(FALSE, "chThdExitS(), #1", "zombies apocalypse");
}
 8000788:	bd38      	pop	{r3, r4, r5, pc}
 800078a:	46c0      	nop			; (mov r8, r8)
 800078c:	20000aa0 	.word	0x20000aa0

08000790 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8000790:	b508      	push	{r3, lr}

  chSysLock();
 8000792:	b672      	cpsid	i
  chThdExitS(msg);
 8000794:	f7ff ffdc 	bl	8000750 <chThdExitS>
  /* The thread never returns here.*/
}
 8000798:	bd08      	pop	{r3, pc}
 800079a:	46c0      	nop			; (mov r8, r8)
 800079c:	46c0      	nop			; (mov r8, r8)
 800079e:	46c0      	nop			; (mov r8, r8)

080007a0 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  vtlist.vt_next = vtlist.vt_prev = (void *)&vtlist;
 80007a0:	4b04      	ldr	r3, [pc, #16]	; (80007b4 <_vt_init+0x14>)
  vtlist.vt_time = (systime_t)-1;
 80007a2:	2201      	movs	r2, #1
 80007a4:	4252      	negs	r2, r2
 80007a6:	609a      	str	r2, [r3, #8]
  vtlist.vt_systime = 0;
 80007a8:	2200      	movs	r2, #0
 *
 * @notapi
 */
void _vt_init(void) {

  vtlist.vt_next = vtlist.vt_prev = (void *)&vtlist;
 80007aa:	605b      	str	r3, [r3, #4]
 80007ac:	601b      	str	r3, [r3, #0]
  vtlist.vt_time = (systime_t)-1;
  vtlist.vt_systime = 0;
 80007ae:	60da      	str	r2, [r3, #12]
}
 80007b0:	4770      	bx	lr
 80007b2:	46c0      	nop			; (mov r8, r8)
 80007b4:	20000be8 	.word	0x20000be8
 80007b8:	46c0      	nop			; (mov r8, r8)
 80007ba:	46c0      	nop			; (mov r8, r8)
 80007bc:	46c0      	nop			; (mov r8, r8)
 80007be:	46c0      	nop			; (mov r8, r8)

080007c0 <chVTSetI>:
 * @param[in] par       a parameter that will be passed to the callback
 *                      function
 *
 * @iclass
 */
void chVTSetI(VirtualTimer *vtp, systime_t time, vtfunc_t vtfunc, void *par) {
 80007c0:	b510      	push	{r4, lr}
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
             "chVTSetI");

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
  p = vtlist.vt_next;
 80007c2:	4c0c      	ldr	r4, [pc, #48]	; (80007f4 <chVTSetI+0x34>)

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
             "chVTSetI");

  vtp->vt_par = par;
 80007c4:	6103      	str	r3, [r0, #16]
  vtp->vt_func = vtfunc;
  p = vtlist.vt_next;
 80007c6:	6823      	ldr	r3, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (time != TIME_IMMEDIATE),
             "chVTSetI");

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
 80007c8:	60c2      	str	r2, [r0, #12]
  p = vtlist.vt_next;
  while (p->vt_time < time) {
 80007ca:	689a      	ldr	r2, [r3, #8]
 80007cc:	4291      	cmp	r1, r2
 80007ce:	d904      	bls.n	80007da <chVTSetI+0x1a>
    time -= p->vt_time;
    p = p->vt_next;
 80007d0:	681b      	ldr	r3, [r3, #0]

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
  p = vtlist.vt_next;
  while (p->vt_time < time) {
    time -= p->vt_time;
 80007d2:	1a89      	subs	r1, r1, r2
             "chVTSetI");

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
  p = vtlist.vt_next;
  while (p->vt_time < time) {
 80007d4:	689a      	ldr	r2, [r3, #8]
 80007d6:	428a      	cmp	r2, r1
 80007d8:	d3fa      	bcc.n	80007d0 <chVTSetI+0x10>
    time -= p->vt_time;
    p = p->vt_next;
  }

  vtp->vt_prev = (vtp->vt_next = p)->vt_prev;
 80007da:	685a      	ldr	r2, [r3, #4]
 80007dc:	6003      	str	r3, [r0, #0]
 80007de:	6042      	str	r2, [r0, #4]
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
 80007e0:	6058      	str	r0, [r3, #4]
 80007e2:	6010      	str	r0, [r2, #0]
  vtp->vt_time = time;
 80007e4:	6081      	str	r1, [r0, #8]
  if (p != (void *)&vtlist)
 80007e6:	42a3      	cmp	r3, r4
 80007e8:	d002      	beq.n	80007f0 <chVTSetI+0x30>
    p->vt_time -= time;
 80007ea:	689a      	ldr	r2, [r3, #8]
 80007ec:	1a51      	subs	r1, r2, r1
 80007ee:	6099      	str	r1, [r3, #8]
}
 80007f0:	bd10      	pop	{r4, pc}
 80007f2:	46c0      	nop			; (mov r8, r8)
 80007f4:	20000be8 	.word	0x20000be8
 80007f8:	46c0      	nop			; (mov r8, r8)
 80007fa:	46c0      	nop			; (mov r8, r8)
 80007fc:	46c0      	nop			; (mov r8, r8)
 80007fe:	46c0      	nop			; (mov r8, r8)

08000800 <chVTResetI>:
  chDbgCheck(vtp != NULL, "chVTResetI");
  chDbgAssert(vtp->vt_func != NULL,
              "chVTResetI(), #1",
              "timer not set or already triggered");

  if (vtp->vt_next != (void *)&vtlist)
 8000800:	6803      	ldr	r3, [r0, #0]
 8000802:	4a07      	ldr	r2, [pc, #28]	; (8000820 <chVTResetI+0x20>)
 *
 * @param[in] vtp       the @p VirtualTimer structure pointer
 *
 * @iclass
 */
void chVTResetI(VirtualTimer *vtp) {
 8000804:	b510      	push	{r4, lr}
  chDbgCheck(vtp != NULL, "chVTResetI");
  chDbgAssert(vtp->vt_func != NULL,
              "chVTResetI(), #1",
              "timer not set or already triggered");

  if (vtp->vt_next != (void *)&vtlist)
 8000806:	4293      	cmp	r3, r2
 8000808:	d003      	beq.n	8000812 <chVTResetI+0x12>
    vtp->vt_next->vt_time += vtp->vt_time;
 800080a:	6899      	ldr	r1, [r3, #8]
 800080c:	6884      	ldr	r4, [r0, #8]
 800080e:	190a      	adds	r2, r1, r4
 8000810:	609a      	str	r2, [r3, #8]
  vtp->vt_prev->vt_next = vtp->vt_next;
 8000812:	6842      	ldr	r2, [r0, #4]
 8000814:	6013      	str	r3, [r2, #0]
  vtp->vt_next->vt_prev = vtp->vt_prev;
 8000816:	6803      	ldr	r3, [r0, #0]
 8000818:	605a      	str	r2, [r3, #4]
  vtp->vt_func = (vtfunc_t)NULL;
 800081a:	2300      	movs	r3, #0
 800081c:	60c3      	str	r3, [r0, #12]
}
 800081e:	bd10      	pop	{r4, pc}
 8000820:	20000be8 	.word	0x20000be8
 8000824:	46c0      	nop			; (mov r8, r8)
 8000826:	46c0      	nop			; (mov r8, r8)
 8000828:	46c0      	nop			; (mov r8, r8)
 800082a:	46c0      	nop			; (mov r8, r8)
 800082c:	46c0      	nop			; (mov r8, r8)
 800082e:	46c0      	nop			; (mov r8, r8)

08000830 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8000830:	b508      	push	{r3, lr}

  hal_lld_init();
 8000832:	f000 f8bd 	bl	80009b0 <hal_lld_init>

#if HAL_USE_TM || defined(__DOXYGEN__)
  tmInit();
#endif
#if HAL_USE_PAL || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 8000836:	4805      	ldr	r0, [pc, #20]	; (800084c <halInit+0x1c>)
 8000838:	f000 fa12 	bl	8000c60 <_pal_lld_init>
#endif
#if HAL_USE_GPT || defined(__DOXYGEN__)
  gptInit();
#endif
#if HAL_USE_I2C || defined(__DOXYGEN__)
  i2cInit();
 800083c:	f000 f808 	bl	8000850 <i2cInit>
#endif
#if HAL_USE_PWM || defined(__DOXYGEN__)
  pwmInit();
#endif
#if HAL_USE_SERIAL || defined(__DOXYGEN__)
  sdInit();
 8000840:	f000 f85e 	bl	8000900 <sdInit>
#endif
#if HAL_USE_RTC || defined(__DOXYGEN__)
  rtcInit();
#endif
  /* Board specific initialization.*/
  boardInit();
 8000844:	f000 fc34 	bl	80010b0 <boardInit>
}
 8000848:	bd08      	pop	{r3, pc}
 800084a:	46c0      	nop			; (mov r8, r8)
 800084c:	08001690 	.word	0x08001690

08000850 <i2cInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void i2cInit(void) {
 8000850:	b508      	push	{r3, lr}
  i2c_lld_init();
 8000852:	f000 f9ed 	bl	8000c30 <i2c_lld_init>
}
 8000856:	bd08      	pop	{r3, pc}
 8000858:	46c0      	nop			; (mov r8, r8)
 800085a:	46c0      	nop			; (mov r8, r8)
 800085c:	46c0      	nop			; (mov r8, r8)
 800085e:	46c0      	nop			; (mov r8, r8)

08000860 <i2cObjectInit>:
 *
 * @param[out] i2cp     pointer to the @p I2CDriver object
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {
 8000860:	b508      	push	{r3, lr}

  i2cp->state  = I2C_STOP;
 8000862:	2301      	movs	r3, #1
 8000864:	7003      	strb	r3, [r0, #0]
  i2cp->config = NULL;
 8000866:	2300      	movs	r3, #0
 8000868:	6043      	str	r3, [r0, #4]

#if I2C_USE_MUTUAL_EXCLUSION
#if CH_USE_MUTEXES
  chMtxInit(&i2cp->mutex);
 800086a:	300c      	adds	r0, #12
 800086c:	f000 fd70 	bl	8001350 <chMtxInit>
#endif /* I2C_USE_MUTUAL_EXCLUSION */

#if defined(I2C_DRIVER_EXT_INIT_HOOK)
  I2C_DRIVER_EXT_INIT_HOOK(i2cp);
#endif
}
 8000870:	bd08      	pop	{r3, pc}
 8000872:	46c0      	nop			; (mov r8, r8)
 8000874:	46c0      	nop			; (mov r8, r8)
 8000876:	46c0      	nop			; (mov r8, r8)
 8000878:	46c0      	nop			; (mov r8, r8)
 800087a:	46c0      	nop			; (mov r8, r8)
 800087c:	46c0      	nop			; (mov r8, r8)
 800087e:	46c0      	nop			; (mov r8, r8)

08000880 <readt>:
static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t time) {

  return chOQWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, time);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t time) {
 8000880:	b508      	push	{r3, lr}

  return chIQReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, time);
 8000882:	300c      	adds	r0, #12
 8000884:	f000 fddc 	bl	8001440 <chIQReadTimeout>
}
 8000888:	bd08      	pop	{r3, pc}
 800088a:	46c0      	nop			; (mov r8, r8)
 800088c:	46c0      	nop			; (mov r8, r8)
 800088e:	46c0      	nop			; (mov r8, r8)

08000890 <read>:

  return chOQWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
                          n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {
 8000890:	b508      	push	{r3, lr}

  return chIQReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8000892:	2301      	movs	r3, #1
 8000894:	300c      	adds	r0, #12
 8000896:	425b      	negs	r3, r3
 8000898:	f000 fdd2 	bl	8001440 <chIQReadTimeout>
                         n, TIME_INFINITE);
}
 800089c:	bd08      	pop	{r3, pc}
 800089e:	46c0      	nop			; (mov r8, r8)

080008a0 <writet>:
static msg_t gett(void *ip, systime_t timeout) {

  return chIQGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t time) {
 80008a0:	b508      	push	{r3, lr}

  return chOQWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, time);
 80008a2:	3030      	adds	r0, #48	; 0x30
 80008a4:	f000 fe64 	bl	8001570 <chOQWriteTimeout>
}
 80008a8:	bd08      	pop	{r3, pc}
 80008aa:	46c0      	nop			; (mov r8, r8)
 80008ac:	46c0      	nop			; (mov r8, r8)
 80008ae:	46c0      	nop			; (mov r8, r8)

080008b0 <write>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
 80008b0:	b508      	push	{r3, lr}

  return chOQWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 80008b2:	2301      	movs	r3, #1
 80008b4:	3030      	adds	r0, #48	; 0x30
 80008b6:	425b      	negs	r3, r3
 80008b8:	f000 fe5a 	bl	8001570 <chOQWriteTimeout>
                          n, TIME_INFINITE);
}
 80008bc:	bd08      	pop	{r3, pc}
 80008be:	46c0      	nop			; (mov r8, r8)

080008c0 <gett>:
static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return chOQPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {
 80008c0:	b508      	push	{r3, lr}

  return chIQGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 80008c2:	300c      	adds	r0, #12
 80008c4:	f000 fd9c 	bl	8001400 <chIQGetTimeout>
}
 80008c8:	bd08      	pop	{r3, pc}
 80008ca:	46c0      	nop			; (mov r8, r8)
 80008cc:	46c0      	nop			; (mov r8, r8)
 80008ce:	46c0      	nop			; (mov r8, r8)

080008d0 <get>:
static msg_t put(void *ip, uint8_t b) {

  return chOQPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {
 80008d0:	b508      	push	{r3, lr}

  return chIQGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 80008d2:	2101      	movs	r1, #1
 80008d4:	300c      	adds	r0, #12
 80008d6:	4249      	negs	r1, r1
 80008d8:	f000 fd92 	bl	8001400 <chIQGetTimeout>
}
 80008dc:	bd08      	pop	{r3, pc}
 80008de:	46c0      	nop			; (mov r8, r8)

080008e0 <putt>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
 80008e0:	b508      	push	{r3, lr}

  return chOQPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 80008e2:	3030      	adds	r0, #48	; 0x30
 80008e4:	f000 fdf4 	bl	80014d0 <chOQPutTimeout>
}
 80008e8:	bd08      	pop	{r3, pc}
 80008ea:	46c0      	nop			; (mov r8, r8)
 80008ec:	46c0      	nop			; (mov r8, r8)
 80008ee:	46c0      	nop			; (mov r8, r8)

080008f0 <put>:

  return chIQReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
                         n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {
 80008f0:	b508      	push	{r3, lr}

  return chOQPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 80008f2:	2201      	movs	r2, #1
 80008f4:	3030      	adds	r0, #48	; 0x30
 80008f6:	4252      	negs	r2, r2
 80008f8:	f000 fdea 	bl	80014d0 <chOQPutTimeout>
}
 80008fc:	bd08      	pop	{r3, pc}
 80008fe:	46c0      	nop			; (mov r8, r8)

08000900 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
 8000900:	b508      	push	{r3, lr}

  sd_lld_init();
 8000902:	f000 faed 	bl	8000ee0 <sd_lld_init>
}
 8000906:	bd08      	pop	{r3, pc}
 8000908:	46c0      	nop			; (mov r8, r8)
 800090a:	46c0      	nop			; (mov r8, r8)
 800090c:	46c0      	nop			; (mov r8, r8)
 800090e:	46c0      	nop			; (mov r8, r8)

08000910 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8000910:	b530      	push	{r4, r5, lr}
 8000912:	1c15      	adds	r5, r2, #0

  sdp->vmt = &vmt;
 8000914:	4a0d      	ldr	r2, [pc, #52]	; (800094c <sdObjectInit+0x3c>)
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8000916:	1c04      	adds	r4, r0, #0

  sdp->vmt = &vmt;
 8000918:	c004      	stmia	r0!, {r2}
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 800091a:	b083      	sub	sp, #12
 800091c:	1c0b      	adds	r3, r1, #0

  sdp->vmt = &vmt;
  chEvtInit(&sdp->event);
 800091e:	6060      	str	r0, [r4, #4]
  sdp->state = SD_STOP;
 8000920:	2201      	movs	r2, #1
  chIQInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8000922:	1c20      	adds	r0, r4, #0
 8000924:	1c21      	adds	r1, r4, #0
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
  chEvtInit(&sdp->event);
  sdp->state = SD_STOP;
 8000926:	7222      	strb	r2, [r4, #8]
  chIQInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8000928:	300c      	adds	r0, #12
 800092a:	3154      	adds	r1, #84	; 0x54
 800092c:	9400      	str	r4, [sp, #0]
 800092e:	2210      	movs	r2, #16
 8000930:	f000 fd2e 	bl	8001390 <chIQInit>
  chOQInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 8000934:	1c20      	adds	r0, r4, #0
 8000936:	1c21      	adds	r1, r4, #0
 8000938:	3030      	adds	r0, #48	; 0x30
 800093a:	3164      	adds	r1, #100	; 0x64
 800093c:	9400      	str	r4, [sp, #0]
 800093e:	2210      	movs	r2, #16
 8000940:	1c2b      	adds	r3, r5, #0
 8000942:	f000 fdb5 	bl	80014b0 <chOQInit>
}
 8000946:	b003      	add	sp, #12
 8000948:	bd30      	pop	{r4, r5, pc}
 800094a:	46c0      	nop			; (mov r8, r8)
 800094c:	08001620 	.word	0x08001620

08000950 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 8000950:	b510      	push	{r4, lr}
 8000952:	1c04      	adds	r4, r0, #0

  chDbgCheck(sdp != NULL, "sdStart");

  chSysLock();
 8000954:	b672      	cpsid	i
  chDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
              "sdStart(), #1",
              "invalid state");
  sd_lld_start(sdp, config);
 8000956:	f000 fadb 	bl	8000f10 <sd_lld_start>
  sdp->state = SD_READY;
 800095a:	2302      	movs	r3, #2
 800095c:	7223      	strb	r3, [r4, #8]
  chSysUnlock();
 800095e:	b662      	cpsie	i
}
 8000960:	bd10      	pop	{r4, pc}
 8000962:	46c0      	nop			; (mov r8, r8)
 8000964:	46c0      	nop			; (mov r8, r8)
 8000966:	46c0      	nop			; (mov r8, r8)
 8000968:	46c0      	nop			; (mov r8, r8)
 800096a:	46c0      	nop			; (mov r8, r8)
 800096c:	46c0      	nop			; (mov r8, r8)
 800096e:	46c0      	nop			; (mov r8, r8)

08000970 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8000970:	b538      	push	{r3, r4, r5, lr}

  chDbgCheckClassI();
  chDbgCheck(sdp != NULL, "sdIncomingDataI");

  if (chIQIsEmptyI(&sdp->iqueue))
 8000972:	6943      	ldr	r3, [r0, #20]
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8000974:	1c04      	adds	r4, r0, #0
 8000976:	1c0d      	adds	r5, r1, #0

  chDbgCheckClassI();
  chDbgCheck(sdp != NULL, "sdIncomingDataI");

  if (chIQIsEmptyI(&sdp->iqueue))
 8000978:	2b00      	cmp	r3, #0
 800097a:	d007      	beq.n	800098c <sdIncomingDataI+0x1c>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (chIQPutI(&sdp->iqueue, b) < Q_OK)
 800097c:	1c20      	adds	r0, r4, #0
 800097e:	300c      	adds	r0, #12
 8000980:	1c29      	adds	r1, r5, #0
 8000982:	f000 fd15 	bl	80013b0 <chIQPutI>
 8000986:	2800      	cmp	r0, #0
 8000988:	db0b      	blt.n	80009a2 <sdIncomingDataI+0x32>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
}
 800098a:	bd38      	pop	{r3, r4, r5, pc}

  chDbgCheckClassI();
  chDbgCheck(sdp != NULL, "sdIncomingDataI");

  if (chIQIsEmptyI(&sdp->iqueue))
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 800098c:	3004      	adds	r0, #4
 800098e:	2104      	movs	r1, #4
 8000990:	f000 fc66 	bl	8001260 <chEvtBroadcastFlagsI>
  if (chIQPutI(&sdp->iqueue, b) < Q_OK)
 8000994:	1c20      	adds	r0, r4, #0
 8000996:	300c      	adds	r0, #12
 8000998:	1c29      	adds	r1, r5, #0
 800099a:	f000 fd09 	bl	80013b0 <chIQPutI>
 800099e:	2800      	cmp	r0, #0
 80009a0:	daf3      	bge.n	800098a <sdIncomingDataI+0x1a>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
 80009a2:	1d20      	adds	r0, r4, #4
 80009a4:	2180      	movs	r1, #128	; 0x80
 80009a6:	f000 fc5b 	bl	8001260 <chEvtBroadcastFlagsI>
 80009aa:	e7ee      	b.n	800098a <sdIncomingDataI+0x1a>
 80009ac:	46c0      	nop			; (mov r8, r8)
 80009ae:	46c0      	nop			; (mov r8, r8)

080009b0 <hal_lld_init>:
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAPB1(0xFFFFFFFF);
 80009b0:	4b1d      	ldr	r3, [pc, #116]	; (8000a28 <hal_lld_init+0x78>)
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 80009b2:	b510      	push	{r4, lr}

  /* Reset of all peripherals.*/
  rccResetAPB1(0xFFFFFFFF);
 80009b4:	691a      	ldr	r2, [r3, #16]
 80009b6:	2201      	movs	r2, #1
 80009b8:	4252      	negs	r2, r2
 80009ba:	611a      	str	r2, [r3, #16]
 80009bc:	2200      	movs	r2, #0
 80009be:	611a      	str	r2, [r3, #16]
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 80009c0:	68d9      	ldr	r1, [r3, #12]
 80009c2:	481a      	ldr	r0, [pc, #104]	; (8000a2c <hal_lld_init+0x7c>)
 80009c4:	4301      	orrs	r1, r0
 80009c6:	60d9      	str	r1, [r3, #12]

  /* SysTick initialization using the system clock.*/
  SysTick->LOAD = STM32_HCLK / CH_FREQUENCY - 1;
 80009c8:	4819      	ldr	r0, [pc, #100]	; (8000a30 <hal_lld_init+0x80>)
 80009ca:	491a      	ldr	r1, [pc, #104]	; (8000a34 <hal_lld_init+0x84>)
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 80009cc:	60da      	str	r2, [r3, #12]

  /* SysTick initialization using the system clock.*/
  SysTick->LOAD = STM32_HCLK / CH_FREQUENCY - 1;
 80009ce:	6048      	str	r0, [r1, #4]
  SysTick->VAL = 0;
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
 80009d0:	2007      	movs	r0, #7
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);

  /* SysTick initialization using the system clock.*/
  SysTick->LOAD = STM32_HCLK / CH_FREQUENCY - 1;
  SysTick->VAL = 0;
 80009d2:	608a      	str	r2, [r1, #8]
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
 80009d4:	6008      	str	r0, [r1, #0]
                  SysTick_CTRL_ENABLE_Msk |
                  SysTick_CTRL_TICKINT_Msk;

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 80009d6:	69d8      	ldr	r0, [r3, #28]
 80009d8:	2180      	movs	r1, #128	; 0x80
 80009da:	0549      	lsls	r1, r1, #21
 80009dc:	4301      	orrs	r1, r0
 80009de:	61d9      	str	r1, [r3, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 80009e0:	4915      	ldr	r1, [pc, #84]	; (8000a38 <hal_lld_init+0x88>)
 80009e2:	2080      	movs	r0, #128	; 0x80
 80009e4:	680c      	ldr	r4, [r1, #0]
 80009e6:	0040      	lsls	r0, r0, #1
 80009e8:	4320      	orrs	r0, r4
 80009ea:	6008      	str	r0, [r1, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 80009ec:	6a19      	ldr	r1, [r3, #32]
 80009ee:	20c0      	movs	r0, #192	; 0xc0
 80009f0:	0080      	lsls	r0, r0, #2
 80009f2:	4008      	ands	r0, r1
 80009f4:	2180      	movs	r1, #128	; 0x80
 80009f6:	0089      	lsls	r1, r1, #2
 80009f8:	4288      	cmp	r0, r1
 80009fa:	d003      	beq.n	8000a04 <hal_lld_init+0x54>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 80009fc:	2180      	movs	r1, #128	; 0x80
 80009fe:	0249      	lsls	r1, r1, #9
 8000a00:	6219      	str	r1, [r3, #32]
    RCC->BDCR = 0;
 8000a02:	621a      	str	r2, [r3, #32]
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 8000a04:	4b08      	ldr	r3, [pc, #32]	; (8000a28 <hal_lld_init+0x78>)
 8000a06:	2280      	movs	r2, #128	; 0x80
 8000a08:	6a19      	ldr	r1, [r3, #32]
 8000a0a:	0212      	lsls	r2, r2, #8
 8000a0c:	4211      	tst	r1, r2
 8000a0e:	d107      	bne.n	8000a20 <hal_lld_init+0x70>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 8000a10:	6a18      	ldr	r0, [r3, #32]
 8000a12:	2180      	movs	r1, #128	; 0x80
 8000a14:	0089      	lsls	r1, r1, #2
 8000a16:	4301      	orrs	r1, r0
 8000a18:	6219      	str	r1, [r3, #32]

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 8000a1a:	6a19      	ldr	r1, [r3, #32]
 8000a1c:	430a      	orrs	r2, r1
 8000a1e:	621a      	str	r2, [r3, #32]

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 8000a20:	f000 fb16 	bl	8001050 <dmaInit>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 8000a24:	bd10      	pop	{r4, pc}
 8000a26:	46c0      	nop			; (mov r8, r8)
 8000a28:	40021000 	.word	0x40021000
 8000a2c:	ffbfffff 	.word	0xffbfffff
 8000a30:	0000bb7f 	.word	0x0000bb7f
 8000a34:	e000e010 	.word	0xe000e010
 8000a38:	40007000 	.word	0x40007000
 8000a3c:	46c0      	nop			; (mov r8, r8)
 8000a3e:	46c0      	nop			; (mov r8, r8)

08000a40 <stm32_clock_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8000a40:	4820      	ldr	r0, [pc, #128]	; (8000ac4 <stm32_clock_init+0x84>)
 8000a42:	2301      	movs	r3, #1
 8000a44:	6802      	ldr	r2, [r0, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8000a46:	2102      	movs	r1, #2
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8000a48:	4313      	orrs	r3, r2
 8000a4a:	6003      	str	r3, [r0, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8000a4c:	6803      	ldr	r3, [r0, #0]
 8000a4e:	4a1d      	ldr	r2, [pc, #116]	; (8000ac4 <stm32_clock_init+0x84>)
 8000a50:	4219      	tst	r1, r3
 8000a52:	d0fb      	beq.n	8000a4c <stm32_clock_init+0xc>
    ;                                       /* Wait until HSI is stable.    */
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8000a54:	6813      	ldr	r3, [r2, #0]
 8000a56:	21f9      	movs	r1, #249	; 0xf9
 8000a58:	400b      	ands	r3, r1
 8000a5a:	6013      	str	r3, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8000a5c:	2300      	movs	r3, #0
 8000a5e:	6053      	str	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8000a60:	200c      	movs	r0, #12
 8000a62:	6853      	ldr	r3, [r2, #4]
 8000a64:	4917      	ldr	r1, [pc, #92]	; (8000ac4 <stm32_clock_init+0x84>)
 8000a66:	4218      	tst	r0, r3
 8000a68:	d1fb      	bne.n	8000a62 <stm32_clock_init+0x22>
    ;                                       /* Waits until HSI14 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8000a6a:	6a4a      	ldr	r2, [r1, #36]	; 0x24
 8000a6c:	2301      	movs	r3, #1
 8000a6e:	4313      	orrs	r3, r2
 8000a70:	624b      	str	r3, [r1, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8000a72:	2002      	movs	r0, #2
 8000a74:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8000a76:	4a13      	ldr	r2, [pc, #76]	; (8000ac4 <stm32_clock_init+0x84>)
 8000a78:	4218      	tst	r0, r3
 8000a7a:	d0fb      	beq.n	8000a74 <stm32_clock_init+0x34>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_MCOSEL | STM32_PLLMUL | STM32_PLLSRC |
 8000a7c:	23a1      	movs	r3, #161	; 0xa1
 8000a7e:	039b      	lsls	r3, r3, #14
 8000a80:	6053      	str	r3, [r2, #4]
               STM32_ADCPRE | STM32_PPRE   | STM32_HPRE;
  RCC->CFGR2 = STM32_PREDIV;
 8000a82:	2300      	movs	r3, #0
 8000a84:	62d3      	str	r3, [r2, #44]	; 0x2c
  RCC->CFGR3 = STM32_ADCSW  | STM32_CECSW  | STM32_I2C1SW |
 8000a86:	6313      	str	r3, [r2, #48]	; 0x30
               STM32_USART1SW;

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8000a88:	6811      	ldr	r1, [r2, #0]
 8000a8a:	2380      	movs	r3, #128	; 0x80
 8000a8c:	045b      	lsls	r3, r3, #17
 8000a8e:	430b      	orrs	r3, r1
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8000a90:	2080      	movs	r0, #128	; 0x80
  RCC->CFGR3 = STM32_ADCSW  | STM32_CECSW  | STM32_I2C1SW |
               STM32_USART1SW;

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8000a92:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8000a94:	0480      	lsls	r0, r0, #18
 8000a96:	6813      	ldr	r3, [r2, #0]
 8000a98:	490a      	ldr	r1, [pc, #40]	; (8000ac4 <stm32_clock_init+0x84>)
 8000a9a:	4203      	tst	r3, r0
 8000a9c:	d0fb      	beq.n	8000a96 <stm32_clock_init+0x56>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8000a9e:	4b0a      	ldr	r3, [pc, #40]	; (8000ac8 <stm32_clock_init+0x88>)
 8000aa0:	2211      	movs	r2, #17
 8000aa2:	601a      	str	r2, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8000aa4:	684a      	ldr	r2, [r1, #4]
 8000aa6:	2302      	movs	r3, #2
 8000aa8:	4313      	orrs	r3, r2
 8000aaa:	604b      	str	r3, [r1, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8000aac:	200c      	movs	r0, #12
 8000aae:	684b      	ldr	r3, [r1, #4]
 8000ab0:	4a04      	ldr	r2, [pc, #16]	; (8000ac4 <stm32_clock_init+0x84>)
 8000ab2:	4003      	ands	r3, r0
 8000ab4:	2b08      	cmp	r3, #8
 8000ab6:	d1fa      	bne.n	8000aae <stm32_clock_init+0x6e>
    ;                                       /* Waits selection complete.    */
#endif

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8000ab8:	6991      	ldr	r1, [r2, #24]
 8000aba:	2301      	movs	r3, #1
 8000abc:	430b      	orrs	r3, r1
 8000abe:	6193      	str	r3, [r2, #24]
#endif /* !STM32_NO_INIT */
}
 8000ac0:	4770      	bx	lr
 8000ac2:	46c0      	nop			; (mov r8, r8)
 8000ac4:	40021000 	.word	0x40021000
 8000ac8:	40022000 	.word	0x40022000
 8000acc:	46c0      	nop			; (mov r8, r8)
 8000ace:	46c0      	nop			; (mov r8, r8)

08000ad0 <Vector9C>:
/**
 * @brief   I2C1 event interrupt handler.
 *
 * @notapi
 */
CH_IRQ_HANDLER(STM32_I2C1_GLOBAL_HANDLER) {
 8000ad0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t isr = I2CD1.i2c->ISR;
 8000ad2:	4b54      	ldr	r3, [pc, #336]	; (8000c24 <Vector9C+0x154>)
 8000ad4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8000ad6:	699b      	ldr	r3, [r3, #24]

  CH_IRQ_PROLOGUE();
 8000ad8:	4674      	mov	r4, lr

  /* Clearing IRQ bits.*/
  I2CD1.i2c->ICR = isr;
 8000ada:	4a52      	ldr	r2, [pc, #328]	; (8000c24 <Vector9C+0x154>)

  if (isr & I2C_ERROR_MASK)
 8000adc:	20fc      	movs	r0, #252	; 0xfc
  uint32_t isr = I2CD1.i2c->ISR;

  CH_IRQ_PROLOGUE();

  /* Clearing IRQ bits.*/
  I2CD1.i2c->ICR = isr;
 8000ade:	6b51      	ldr	r1, [r2, #52]	; 0x34

  if (isr & I2C_ERROR_MASK)
 8000ae0:	0180      	lsls	r0, r0, #6
  uint32_t isr = I2CD1.i2c->ISR;

  CH_IRQ_PROLOGUE();

  /* Clearing IRQ bits.*/
  I2CD1.i2c->ICR = isr;
 8000ae2:	61cb      	str	r3, [r1, #28]

  if (isr & I2C_ERROR_MASK)
 8000ae4:	4203      	tst	r3, r0
 8000ae6:	d13b      	bne.n	8000b60 <Vector9C+0x90>
    i2c_lld_serve_error_interrupt(&I2CD1, isr);
  else if (isr & I2C_INT_MASK)
 8000ae8:	20fe      	movs	r0, #254	; 0xfe
 8000aea:	4218      	tst	r0, r3
 8000aec:	d103      	bne.n	8000af6 <Vector9C+0x26>
    i2c_lld_serve_interrupt(&I2CD1, isr);

  CH_IRQ_EPILOGUE();
 8000aee:	1c20      	adds	r0, r4, #0
 8000af0:	f000 fafe 	bl	80010f0 <_port_irq_epilogue>
}
 8000af4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 * @notapi
 */
static void i2c_lld_serve_interrupt(I2CDriver *i2cp, uint32_t isr) {
  I2C_TypeDef *dp = i2cp->i2c;

  if ((isr & I2C_ISR_TC) && (i2cp->state == I2C_ACTIVE_TX)) {
 8000af6:	2040      	movs	r0, #64	; 0x40
 8000af8:	4218      	tst	r0, r3
 8000afa:	d002      	beq.n	8000b02 <Vector9C+0x32>
 8000afc:	7815      	ldrb	r5, [r2, #0]
 8000afe:	2d03      	cmp	r5, #3
 8000b00:	d069      	beq.n	8000bd6 <Vector9C+0x106>
    else {
      /* Nothing to receive - send STOP immediately.*/
      dp->CR2 |= I2C_CR2_STOP;
    }
  }
  if (isr & I2C_ISR_NACKF) {
 8000b02:	06de      	lsls	r6, r3, #27
 8000b04:	d508      	bpl.n	8000b18 <Vector9C+0x48>
    /* Starts a STOP sequence immediately on error.*/
    dp->CR2 |= I2C_CR2_STOP;
 8000b06:	684d      	ldr	r5, [r1, #4]
 8000b08:	2080      	movs	r0, #128	; 0x80
 8000b0a:	01c0      	lsls	r0, r0, #7
 8000b0c:	4328      	orrs	r0, r5
 8000b0e:	6048      	str	r0, [r1, #4]

    i2cp->errors |= I2CD_ACK_FAILURE;
 8000b10:	6890      	ldr	r0, [r2, #8]
 8000b12:	2104      	movs	r1, #4
 8000b14:	4301      	orrs	r1, r0
 8000b16:	6091      	str	r1, [r2, #8]
  }
  if (isr & I2C_ISR_STOPF) {
 8000b18:	0699      	lsls	r1, r3, #26
 8000b1a:	d5e8      	bpl.n	8000aee <Vector9C+0x1e>
    /* Stops the associated DMA streams.*/
    dmaStreamDisable(i2cp->dmatx);
 8000b1c:	6b11      	ldr	r1, [r2, #48]	; 0x30
 8000b1e:	230f      	movs	r3, #15
 8000b20:	6808      	ldr	r0, [r1, #0]
 8000b22:	6805      	ldr	r5, [r0, #0]
 8000b24:	439d      	bics	r5, r3
 8000b26:	6005      	str	r5, [r0, #0]
 8000b28:	6848      	ldr	r0, [r1, #4]
 8000b2a:	7a09      	ldrb	r1, [r1, #8]
 8000b2c:	1c1d      	adds	r5, r3, #0
 8000b2e:	408d      	lsls	r5, r1
    dmaStreamDisable(i2cp->dmarx);
 8000b30:	6ad1      	ldr	r1, [r2, #44]	; 0x2c

    i2cp->errors |= I2CD_ACK_FAILURE;
  }
  if (isr & I2C_ISR_STOPF) {
    /* Stops the associated DMA streams.*/
    dmaStreamDisable(i2cp->dmatx);
 8000b32:	6005      	str	r5, [r0, #0]
    dmaStreamDisable(i2cp->dmarx);
 8000b34:	6808      	ldr	r0, [r1, #0]
 8000b36:	6805      	ldr	r5, [r0, #0]
 8000b38:	439d      	bics	r5, r3
 8000b3a:	6005      	str	r5, [r0, #0]
 8000b3c:	6848      	ldr	r0, [r1, #4]
 8000b3e:	7a09      	ldrb	r1, [r1, #8]
 8000b40:	408b      	lsls	r3, r1
 8000b42:	6003      	str	r3, [r0, #0]

    if (i2cp->errors) {
 8000b44:	6896      	ldr	r6, [r2, #8]
 8000b46:	2e00      	cmp	r6, #0
 8000b48:	d130      	bne.n	8000bac <Vector9C+0xdc>
      wakeup_isr(i2cp, RDY_RESET);
    }
    else {
      wakeup_isr(i2cp, RDY_OK);
 8000b4a:	b672      	cpsid	i
 8000b4c:	69d0      	ldr	r0, [r2, #28]
 8000b4e:	2800      	cmp	r0, #0
 8000b50:	d004      	beq.n	8000b5c <Vector9C+0x8c>
 8000b52:	2300      	movs	r3, #0
 8000b54:	61d3      	str	r3, [r2, #28]
 8000b56:	6243      	str	r3, [r0, #36]	; 0x24
 8000b58:	f7ff fc62 	bl	8000420 <chSchReadyI>
 8000b5c:	b662      	cpsie	i
 8000b5e:	e7c6      	b.n	8000aee <Vector9C+0x1e>
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint32_t isr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8000b60:	6b10      	ldr	r0, [r2, #48]	; 0x30
 8000b62:	210f      	movs	r1, #15
 8000b64:	6805      	ldr	r5, [r0, #0]
 8000b66:	682e      	ldr	r6, [r5, #0]
 8000b68:	438e      	bics	r6, r1
 8000b6a:	602e      	str	r6, [r5, #0]
 8000b6c:	6845      	ldr	r5, [r0, #4]
 8000b6e:	7a00      	ldrb	r0, [r0, #8]
 8000b70:	1c0e      	adds	r6, r1, #0
 8000b72:	4086      	lsls	r6, r0
  dmaStreamDisable(i2cp->dmarx);
 8000b74:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint32_t isr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8000b76:	602e      	str	r6, [r5, #0]
  dmaStreamDisable(i2cp->dmarx);
 8000b78:	6805      	ldr	r5, [r0, #0]
 8000b7a:	682e      	ldr	r6, [r5, #0]
 8000b7c:	438e      	bics	r6, r1
 8000b7e:	602e      	str	r6, [r5, #0]
 8000b80:	6845      	ldr	r5, [r0, #4]
 8000b82:	7a00      	ldrb	r0, [r0, #8]
 8000b84:	4081      	lsls	r1, r0
 8000b86:	6029      	str	r1, [r5, #0]

  if (isr & I2C_ISR_BERR)
 8000b88:	05d8      	lsls	r0, r3, #23
 8000b8a:	d41b      	bmi.n	8000bc4 <Vector9C+0xf4>
 8000b8c:	6891      	ldr	r1, [r2, #8]
    i2cp->errors |= I2CD_BUS_ERROR;

  if (isr & I2C_ISR_ARLO)
 8000b8e:	059e      	lsls	r6, r3, #22
 8000b90:	d502      	bpl.n	8000b98 <Vector9C+0xc8>
    i2cp->errors |= I2CD_ARBITRATION_LOST;
 8000b92:	2002      	movs	r0, #2
 8000b94:	4301      	orrs	r1, r0
 8000b96:	6091      	str	r1, [r2, #8]

  if (isr & I2C_ISR_OVR)
 8000b98:	0558      	lsls	r0, r3, #21
 8000b9a:	d502      	bpl.n	8000ba2 <Vector9C+0xd2>
    i2cp->errors |= I2CD_OVERRUN;
 8000b9c:	2008      	movs	r0, #8
 8000b9e:	4301      	orrs	r1, r0
 8000ba0:	6091      	str	r1, [r2, #8]

  if (isr & I2C_ISR_TIMEOUT)
 8000ba2:	04dd      	lsls	r5, r3, #19
 8000ba4:	d513      	bpl.n	8000bce <Vector9C+0xfe>
    i2cp->errors |= I2CD_TIMEOUT;
 8000ba6:	2320      	movs	r3, #32
 8000ba8:	4319      	orrs	r1, r3
 8000baa:	6091      	str	r1, [r2, #8]
    /* Stops the associated DMA streams.*/
    dmaStreamDisable(i2cp->dmatx);
    dmaStreamDisable(i2cp->dmarx);

    if (i2cp->errors) {
      wakeup_isr(i2cp, RDY_RESET);
 8000bac:	b672      	cpsid	i
 8000bae:	69d0      	ldr	r0, [r2, #28]
 8000bb0:	2800      	cmp	r0, #0
 8000bb2:	d0d3      	beq.n	8000b5c <Vector9C+0x8c>
 8000bb4:	2300      	movs	r3, #0
 8000bb6:	61d3      	str	r3, [r2, #28]
 8000bb8:	2302      	movs	r3, #2
 8000bba:	425b      	negs	r3, r3
 8000bbc:	6243      	str	r3, [r0, #36]	; 0x24
 8000bbe:	f7ff fc2f 	bl	8000420 <chSchReadyI>
 8000bc2:	e7cb      	b.n	8000b5c <Vector9C+0x8c>
  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
  dmaStreamDisable(i2cp->dmarx);

  if (isr & I2C_ISR_BERR)
    i2cp->errors |= I2CD_BUS_ERROR;
 8000bc4:	6895      	ldr	r5, [r2, #8]
 8000bc6:	2101      	movs	r1, #1
 8000bc8:	4329      	orrs	r1, r5
 8000bca:	6091      	str	r1, [r2, #8]
 8000bcc:	e7df      	b.n	8000b8e <Vector9C+0xbe>

  if (isr & I2C_ISR_TIMEOUT)
    i2cp->errors |= I2CD_TIMEOUT;

  /* If some error has been identified then sends wakes the waiting thread.*/
  if (i2cp->errors != I2CD_NO_ERROR)
 8000bce:	2900      	cmp	r1, #0
 8000bd0:	d100      	bne.n	8000bd4 <Vector9C+0x104>
 8000bd2:	e78c      	b.n	8000aee <Vector9C+0x1e>
 8000bd4:	e7ea      	b.n	8000bac <Vector9C+0xdc>

  if ((isr & I2C_ISR_TC) && (i2cp->state == I2C_ACTIVE_TX)) {
    size_t rxbytes;

    /* Make sure no more 'Transfer complete' interrupts.*/
    dp->CR1 &= ~I2C_CR1_TCIE;
 8000bd6:	680d      	ldr	r5, [r1, #0]
 8000bd8:	4385      	bics	r5, r0

    rxbytes = dmaStreamGetTransactionSize(i2cp->dmarx);
 8000bda:	6ad0      	ldr	r0, [r2, #44]	; 0x2c

  if ((isr & I2C_ISR_TC) && (i2cp->state == I2C_ACTIVE_TX)) {
    size_t rxbytes;

    /* Make sure no more 'Transfer complete' interrupts.*/
    dp->CR1 &= ~I2C_CR1_TCIE;
 8000bdc:	600d      	str	r5, [r1, #0]

    rxbytes = dmaStreamGetTransactionSize(i2cp->dmarx);
 8000bde:	6800      	ldr	r0, [r0, #0]
 8000be0:	6845      	ldr	r5, [r0, #4]
    if (rxbytes > 0) {
 8000be2:	2d00      	cmp	r5, #0
 8000be4:	d018      	beq.n	8000c18 <Vector9C+0x148>
      i2cp->state = I2C_ACTIVE_RX;

      /* Enable RX DMA */
      dmaStreamEnable(i2cp->dmarx);
 8000be6:	6807      	ldr	r7, [r0, #0]
    /* Make sure no more 'Transfer complete' interrupts.*/
    dp->CR1 &= ~I2C_CR1_TCIE;

    rxbytes = dmaStreamGetTransactionSize(i2cp->dmarx);
    if (rxbytes > 0) {
      i2cp->state = I2C_ACTIVE_RX;
 8000be8:	2604      	movs	r6, #4
 8000bea:	7016      	strb	r6, [r2, #0]

      /* Enable RX DMA */
      dmaStreamEnable(i2cp->dmarx);
 8000bec:	2601      	movs	r6, #1
 8000bee:	433e      	orrs	r6, r7
 8000bf0:	6006      	str	r6, [r0, #0]

      dp->CR2 &= ~I2C_CR2_NBYTES;
 8000bf2:	684e      	ldr	r6, [r1, #4]
 8000bf4:	480c      	ldr	r0, [pc, #48]	; (8000c28 <Vector9C+0x158>)
      dp->CR2 |= rxbytes << 16;
 8000bf6:	042d      	lsls	r5, r5, #16
      i2cp->state = I2C_ACTIVE_RX;

      /* Enable RX DMA */
      dmaStreamEnable(i2cp->dmarx);

      dp->CR2 &= ~I2C_CR2_NBYTES;
 8000bf8:	4030      	ands	r0, r6
 8000bfa:	6048      	str	r0, [r1, #4]
      dp->CR2 |= rxbytes << 16;
 8000bfc:	6848      	ldr	r0, [r1, #4]
 8000bfe:	4305      	orrs	r5, r0
 8000c00:	604d      	str	r5, [r1, #4]

      /* Starts the read operation.*/
      dp->CR2 |= I2C_CR2_RD_WRN;
 8000c02:	684d      	ldr	r5, [r1, #4]
 8000c04:	2080      	movs	r0, #128	; 0x80
 8000c06:	00c0      	lsls	r0, r0, #3
 8000c08:	4328      	orrs	r0, r5
 8000c0a:	6048      	str	r0, [r1, #4]
      dp->CR2 |= I2C_CR2_START;
 8000c0c:	684d      	ldr	r5, [r1, #4]
 8000c0e:	2080      	movs	r0, #128	; 0x80
 8000c10:	0180      	lsls	r0, r0, #6
 8000c12:	4328      	orrs	r0, r5
 8000c14:	6048      	str	r0, [r1, #4]
 8000c16:	e774      	b.n	8000b02 <Vector9C+0x32>
    }
    else {
      /* Nothing to receive - send STOP immediately.*/
      dp->CR2 |= I2C_CR2_STOP;
 8000c18:	684d      	ldr	r5, [r1, #4]
 8000c1a:	2080      	movs	r0, #128	; 0x80
 8000c1c:	01c0      	lsls	r0, r0, #7
 8000c1e:	4328      	orrs	r0, r5
 8000c20:	6048      	str	r0, [r1, #4]
 8000c22:	e76e      	b.n	8000b02 <Vector9C+0x32>
 8000c24:	20000bf8 	.word	0x20000bf8
 8000c28:	ff00ffff 	.word	0xff00ffff
 8000c2c:	46c0      	nop			; (mov r8, r8)
 8000c2e:	46c0      	nop			; (mov r8, r8)

08000c30 <i2c_lld_init>:
/**
 * @brief   Low level I2C driver initialization.
 *
 * @notapi
 */
void i2c_lld_init(void) {
 8000c30:	b510      	push	{r4, lr}

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
 8000c32:	4c06      	ldr	r4, [pc, #24]	; (8000c4c <i2c_lld_init+0x1c>)
 8000c34:	1c20      	adds	r0, r4, #0
 8000c36:	f7ff fe13 	bl	8000860 <i2cObjectInit>
  I2CD1.thread = NULL;
 8000c3a:	2300      	movs	r3, #0
 8000c3c:	61e3      	str	r3, [r4, #28]
  I2CD1.i2c    = I2C1;
 8000c3e:	4b04      	ldr	r3, [pc, #16]	; (8000c50 <i2c_lld_init+0x20>)
 8000c40:	6363      	str	r3, [r4, #52]	; 0x34
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
 8000c42:	4b04      	ldr	r3, [pc, #16]	; (8000c54 <i2c_lld_init+0x24>)
 8000c44:	62e3      	str	r3, [r4, #44]	; 0x2c
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
 8000c46:	3b0c      	subs	r3, #12
 8000c48:	6323      	str	r3, [r4, #48]	; 0x30
  I2CD2.thread = NULL;
  I2CD2.i2c    = I2C2;
  I2CD2.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C2_RX_DMA_STREAM);
  I2CD2.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C2_TX_DMA_STREAM);
#endif /* STM32_I2C_USE_I2C2 */
}
 8000c4a:	bd10      	pop	{r4, pc}
 8000c4c:	20000bf8 	.word	0x20000bf8
 8000c50:	40005400 	.word	0x40005400
 8000c54:	08001668 	.word	0x08001668
 8000c58:	46c0      	nop			; (mov r8, r8)
 8000c5a:	46c0      	nop			; (mov r8, r8)
 8000c5c:	46c0      	nop			; (mov r8, r8)
 8000c5e:	46c0      	nop			; (mov r8, r8)

08000c60 <_pal_lld_init>:
   */
#if defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8000c60:	4b2a      	ldr	r3, [pc, #168]	; (8000d0c <_pal_lld_init+0xac>)
 8000c62:	22bc      	movs	r2, #188	; 0xbc
 8000c64:	6959      	ldr	r1, [r3, #20]
 8000c66:	03d2      	lsls	r2, r2, #15
 8000c68:	430a      	orrs	r2, r1
 8000c6a:	615a      	str	r2, [r3, #20]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(GPIO_TypeDef *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000c6c:	6842      	ldr	r2, [r0, #4]
 8000c6e:	2390      	movs	r3, #144	; 0x90
 8000c70:	05db      	lsls	r3, r3, #23
 8000c72:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000c74:	6882      	ldr	r2, [r0, #8]
 8000c76:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8000c78:	68c2      	ldr	r2, [r0, #12]
 8000c7a:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 8000c7c:	6902      	ldr	r2, [r0, #16]
 8000c7e:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8000c80:	6942      	ldr	r2, [r0, #20]
 8000c82:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8000c84:	6982      	ldr	r2, [r0, #24]
 8000c86:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000c88:	6802      	ldr	r2, [r0, #0]
 8000c8a:	601a      	str	r2, [r3, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(GPIO_TypeDef *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000c8c:	6a02      	ldr	r2, [r0, #32]
 8000c8e:	4b20      	ldr	r3, [pc, #128]	; (8000d10 <_pal_lld_init+0xb0>)
 8000c90:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000c92:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8000c94:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8000c96:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8000c98:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 8000c9a:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8000c9c:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8000c9e:	6b02      	ldr	r2, [r0, #48]	; 0x30
 8000ca0:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8000ca2:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8000ca4:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000ca6:	69c2      	ldr	r2, [r0, #28]
 8000ca8:	601a      	str	r2, [r3, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(GPIO_TypeDef *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000caa:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 8000cac:	4b19      	ldr	r3, [pc, #100]	; (8000d14 <_pal_lld_init+0xb4>)
 8000cae:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000cb0:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8000cb2:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8000cb4:	6c42      	ldr	r2, [r0, #68]	; 0x44
 8000cb6:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 8000cb8:	6c82      	ldr	r2, [r0, #72]	; 0x48
 8000cba:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8000cbc:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
 8000cbe:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8000cc0:	6d02      	ldr	r2, [r0, #80]	; 0x50
 8000cc2:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000cc4:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8000cc6:	601a      	str	r2, [r3, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(GPIO_TypeDef *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000cc8:	6d82      	ldr	r2, [r0, #88]	; 0x58
 8000cca:	4b13      	ldr	r3, [pc, #76]	; (8000d18 <_pal_lld_init+0xb8>)
 8000ccc:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000cce:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
 8000cd0:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8000cd2:	6e02      	ldr	r2, [r0, #96]	; 0x60
 8000cd4:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 8000cd6:	6e42      	ldr	r2, [r0, #100]	; 0x64
 8000cd8:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8000cda:	6e82      	ldr	r2, [r0, #104]	; 0x68
 8000cdc:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8000cde:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 8000ce0:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000ce2:	6d42      	ldr	r2, [r0, #84]	; 0x54
 8000ce4:	601a      	str	r2, [r3, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(GPIO_TypeDef *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000ce6:	6f42      	ldr	r2, [r0, #116]	; 0x74
 8000ce8:	4b0c      	ldr	r3, [pc, #48]	; (8000d1c <_pal_lld_init+0xbc>)
 8000cea:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000cec:	6f82      	ldr	r2, [r0, #120]	; 0x78
 8000cee:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8000cf0:	6fc2      	ldr	r2, [r0, #124]	; 0x7c
 8000cf2:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 8000cf4:	2280      	movs	r2, #128	; 0x80
 8000cf6:	5882      	ldr	r2, [r0, r2]
 8000cf8:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8000cfa:	2284      	movs	r2, #132	; 0x84
 8000cfc:	5882      	ldr	r2, [r0, r2]
 8000cfe:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8000d00:	2288      	movs	r2, #136	; 0x88
 8000d02:	5882      	ldr	r2, [r0, r2]
 8000d04:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000d06:	6f02      	ldr	r2, [r0, #112]	; 0x70
 8000d08:	601a      	str	r2, [r3, #0]
  initgpio(GPIOH, &config->PHData);
#endif
#if STM32_HAS_GPIOI
  initgpio(GPIOI, &config->PIData);
#endif
}
 8000d0a:	4770      	bx	lr
 8000d0c:	40021000 	.word	0x40021000
 8000d10:	48000400 	.word	0x48000400
 8000d14:	48000800 	.word	0x48000800
 8000d18:	48000c00 	.word	0x48000c00
 8000d1c:	48001400 	.word	0x48001400

08000d20 <_pal_lld_setgroupmode>:
 * @notapi
 */
#if 1
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8000d20:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000d22:	4656      	mov	r6, sl
 8000d24:	464d      	mov	r5, r9
 8000d26:	465f      	mov	r7, fp
 8000d28:	4644      	mov	r4, r8
 8000d2a:	b4f0      	push	{r4, r5, r6, r7}

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8000d2c:	2703      	movs	r7, #3
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8000d2e:	0756      	lsls	r6, r2, #29
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 8000d30:	06d5      	lsls	r5, r2, #27
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
 8000d32:	0654      	lsls	r4, r2, #25
#if 1
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8000d34:	4017      	ands	r7, r2
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 8000d36:	0552      	lsls	r2, r2, #21
 8000d38:	0f12      	lsrs	r2, r2, #28
  uint32_t bit     = 0;
  while (TRUE) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8000d3a:	2307      	movs	r3, #7
 * @notapi
 */
#if 1
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8000d3c:	b083      	sub	sp, #12

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
 8000d3e:	0fa4      	lsrs	r4, r4, #30
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 8000d40:	4692      	mov	sl, r2
  uint32_t bit     = 0;
 8000d42:	2200      	movs	r2, #0
  while (TRUE) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8000d44:	4699      	mov	r9, r3
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8000d46:	0ff6      	lsrs	r6, r6, #31
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 8000d48:	0fad      	lsrs	r5, r5, #30
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      m2 = 3 << (bit * 2);
 8000d4a:	9401      	str	r4, [sp, #4]
 8000d4c:	1c13      	adds	r3, r2, #0
 8000d4e:	e02b      	b.n	8000da8 <_pal_lld_setgroupmode+0x88>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
        port->AFRL = (port->AFRL & ~m4) | altrmask;
 8000d50:	6a02      	ldr	r2, [r0, #32]
 8000d52:	43a2      	bics	r2, r4
 8000d54:	4644      	mov	r4, r8
 8000d56:	4322      	orrs	r2, r4
 8000d58:	6202      	str	r2, [r0, #32]
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8000d5a:	6844      	ldr	r4, [r0, #4]
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
 8000d5c:	2201      	movs	r2, #1
 8000d5e:	409a      	lsls	r2, r3
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8000d60:	4394      	bics	r4, r2
 8000d62:	4334      	orrs	r4, r6
 8000d64:	6044      	str	r4, [r0, #4]
      m2 = 3 << (bit * 2);
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8000d66:	6882      	ldr	r2, [r0, #8]
 8000d68:	005c      	lsls	r4, r3, #1
 8000d6a:	4690      	mov	r8, r2
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      m2 = 3 << (bit * 2);
 8000d6c:	2203      	movs	r2, #3
 8000d6e:	40a2      	lsls	r2, r4
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8000d70:	43d2      	mvns	r2, r2
 8000d72:	4644      	mov	r4, r8
 8000d74:	4014      	ands	r4, r2
 8000d76:	432c      	orrs	r4, r5
 8000d78:	6084      	str	r4, [r0, #8]
 8000d7a:	4694      	mov	ip, r2
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8000d7c:	68c2      	ldr	r2, [r0, #12]
 8000d7e:	1c14      	adds	r4, r2, #0
 8000d80:	4662      	mov	r2, ip
 8000d82:	4014      	ands	r4, r2
 8000d84:	9a01      	ldr	r2, [sp, #4]
 8000d86:	4314      	orrs	r4, r2
 8000d88:	60c4      	str	r4, [r0, #12]
      port->MODER   = (port->MODER & ~m2) | moder;
 8000d8a:	6804      	ldr	r4, [r0, #0]
 8000d8c:	1c22      	adds	r2, r4, #0
 8000d8e:	4664      	mov	r4, ip
 8000d90:	4022      	ands	r2, r4
 8000d92:	433a      	orrs	r2, r7
 8000d94:	6002      	str	r2, [r0, #0]
    }
    mask >>= 1;
 8000d96:	0849      	lsrs	r1, r1, #1
    if (!mask)
 8000d98:	d01c      	beq.n	8000dd4 <_pal_lld_setgroupmode+0xb4>
      return;
    otyper <<= 1;
    ospeedr <<= 2;
    pupdr <<= 2;
 8000d9a:	9a01      	ldr	r2, [sp, #4]
      port->MODER   = (port->MODER & ~m2) | moder;
    }
    mask >>= 1;
    if (!mask)
      return;
    otyper <<= 1;
 8000d9c:	0076      	lsls	r6, r6, #1
    ospeedr <<= 2;
    pupdr <<= 2;
 8000d9e:	0092      	lsls	r2, r2, #2
    }
    mask >>= 1;
    if (!mask)
      return;
    otyper <<= 1;
    ospeedr <<= 2;
 8000da0:	00ad      	lsls	r5, r5, #2
    pupdr <<= 2;
 8000da2:	9201      	str	r2, [sp, #4]
    moder <<= 2;
 8000da4:	00bf      	lsls	r7, r7, #2
    bit++;
 8000da6:	3301      	adds	r3, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (TRUE) {
    if ((mask & 1) != 0) {
 8000da8:	2401      	movs	r4, #1
 8000daa:	420c      	tst	r4, r1
 8000dac:	d0f3      	beq.n	8000d96 <_pal_lld_setgroupmode+0x76>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8000dae:	464a      	mov	r2, r9
 8000db0:	401a      	ands	r2, r3
 8000db2:	0092      	lsls	r2, r2, #2
 8000db4:	4654      	mov	r4, sl
 8000db6:	4094      	lsls	r4, r2
 8000db8:	46a0      	mov	r8, r4
      m4 = 15 << ((bit & 7) * 4);
 8000dba:	240f      	movs	r4, #15
 8000dbc:	4094      	lsls	r4, r2
 8000dbe:	46a4      	mov	ip, r4
      if (bit < 8)
 8000dc0:	2b07      	cmp	r3, #7
 8000dc2:	d9c5      	bls.n	8000d50 <_pal_lld_setgroupmode+0x30>
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
 8000dc4:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8000dc6:	1c14      	adds	r4, r2, #0
 8000dc8:	4662      	mov	r2, ip
 8000dca:	4394      	bics	r4, r2
 8000dcc:	4642      	mov	r2, r8
 8000dce:	4314      	orrs	r4, r2
 8000dd0:	6244      	str	r4, [r0, #36]	; 0x24
 8000dd2:	e7c2      	b.n	8000d5a <_pal_lld_setgroupmode+0x3a>
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
    bit++;
  }
}
 8000dd4:	b003      	add	sp, #12
 8000dd6:	bc3c      	pop	{r2, r3, r4, r5}
 8000dd8:	4690      	mov	r8, r2
 8000dda:	4699      	mov	r9, r3
 8000ddc:	46a2      	mov	sl, r4
 8000dde:	46ab      	mov	fp, r5
 8000de0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000de2:	46c0      	nop			; (mov r8, r8)
 8000de4:	46c0      	nop			; (mov r8, r8)
 8000de6:	46c0      	nop			; (mov r8, r8)
 8000de8:	46c0      	nop			; (mov r8, r8)
 8000dea:	46c0      	nop			; (mov r8, r8)
 8000dec:	46c0      	nop			; (mov r8, r8)
 8000dee:	46c0      	nop			; (mov r8, r8)

08000df0 <notify1>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(GenericQueue *qp) {

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
 8000df0:	4b02      	ldr	r3, [pc, #8]	; (8000dfc <notify1+0xc>)
 8000df2:	2280      	movs	r2, #128	; 0x80
 8000df4:	6819      	ldr	r1, [r3, #0]
 8000df6:	430a      	orrs	r2, r1
 8000df8:	601a      	str	r2, [r3, #0]
}
 8000dfa:	4770      	bx	lr
 8000dfc:	40013800 	.word	0x40013800

08000e00 <VectorAC>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8000e00:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000e02:	4647      	mov	r7, r8
 8000e04:	b480      	push	{r7}

  CH_IRQ_PROLOGUE();
 8000e06:	46f0      	mov	r8, lr
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 8000e08:	4e32      	ldr	r6, [pc, #200]	; (8000ed4 <VectorAC+0xd4>)
 8000e0a:	6f75      	ldr	r5, [r6, #116]	; 0x74
  uint32_t cr1 = u->CR1;
 8000e0c:	682f      	ldr	r7, [r5, #0]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 8000e0e:	69ec      	ldr	r4, [r5, #28]
  u->ICR = isr;
 8000e10:	622c      	str	r4, [r5, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 8000e12:	0722      	lsls	r2, r4, #28
 8000e14:	d129      	bne.n	8000e6a <VectorAC+0x6a>
    set_error(sdp, isr);

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBD) {
 8000e16:	05e2      	lsls	r2, r4, #23
 8000e18:	d41f      	bmi.n	8000e5a <VectorAC+0x5a>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    chSysUnlockFromIsr();
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
 8000e1a:	06a3      	lsls	r3, r4, #26
 8000e1c:	d415      	bmi.n	8000e4a <VectorAC+0x4a>
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
    chSysUnlockFromIsr();
  }

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
 8000e1e:	2380      	movs	r3, #128	; 0x80
 8000e20:	423b      	tst	r3, r7
 8000e22:	d001      	beq.n	8000e28 <VectorAC+0x28>
 8000e24:	4223      	tst	r3, r4
 8000e26:	d136      	bne.n	8000e96 <VectorAC+0x96>
      u->TDR = b;
    chSysUnlockFromIsr();
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
 8000e28:	0662      	lsls	r2, r4, #25
 8000e2a:	d508      	bpl.n	8000e3e <VectorAC+0x3e>
    chSysLockFromIsr();
 8000e2c:	b672      	cpsid	i
    if (chOQIsEmptyI(&sdp->oqueue))
 8000e2e:	6c73      	ldr	r3, [r6, #68]	; 0x44
 8000e30:	6cb2      	ldr	r2, [r6, #72]	; 0x48
 8000e32:	4293      	cmp	r3, r2
 8000e34:	d03a      	beq.n	8000eac <VectorAC+0xac>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8000e36:	2340      	movs	r3, #64	; 0x40
 8000e38:	439f      	bics	r7, r3
 8000e3a:	602f      	str	r7, [r5, #0]
    chSysUnlockFromIsr();
 8000e3c:	b662      	cpsie	i

  CH_IRQ_PROLOGUE();

  serve_interrupt(&SD1);

  CH_IRQ_EPILOGUE();
 8000e3e:	4640      	mov	r0, r8
 8000e40:	f000 f956 	bl	80010f0 <_port_irq_epilogue>
}
 8000e44:	bc04      	pop	{r2}
 8000e46:	4690      	mov	r8, r2
 8000e48:	bdf0      	pop	{r4, r5, r6, r7, pc}
    chSysUnlockFromIsr();
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
    chSysLockFromIsr();
 8000e4a:	b672      	cpsid	i
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
 8000e4c:	6a69      	ldr	r1, [r5, #36]	; 0x24
 8000e4e:	1c30      	adds	r0, r6, #0
 8000e50:	b2c9      	uxtb	r1, r1
 8000e52:	f7ff fd8d 	bl	8000970 <sdIncomingDataI>
    chSysUnlockFromIsr();
 8000e56:	b662      	cpsie	i
 8000e58:	e7e1      	b.n	8000e1e <VectorAC+0x1e>
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
    set_error(sdp, isr);

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBD) {
    chSysLockFromIsr();
 8000e5a:	b672      	cpsid	i
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 8000e5c:	2180      	movs	r1, #128	; 0x80
 8000e5e:	1d30      	adds	r0, r6, #4
 8000e60:	0089      	lsls	r1, r1, #2
 8000e62:	f000 f9fd 	bl	8001260 <chEvtBroadcastFlagsI>
    chSysUnlockFromIsr();
 8000e66:	b662      	cpsie	i
 8000e68:	e7d7      	b.n	8000e1a <VectorAC+0x1a>
 * @param[in] isr       USART ISR register value
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
  flagsmask_t sts = 0;

  if (isr & USART_ISR_ORE)
 8000e6a:	0721      	lsls	r1, r4, #28
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] isr       USART ISR register value
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
  flagsmask_t sts = 0;
 8000e6c:	0fc9      	lsrs	r1, r1, #31
 8000e6e:	01c9      	lsls	r1, r1, #7

  if (isr & USART_ISR_ORE)
    sts |= SD_OVERRUN_ERROR;
  if (isr & USART_ISR_PE)
 8000e70:	07e3      	lsls	r3, r4, #31
 8000e72:	d501      	bpl.n	8000e78 <VectorAC+0x78>
    sts |= SD_PARITY_ERROR;
 8000e74:	2320      	movs	r3, #32
 8000e76:	4319      	orrs	r1, r3
  if (isr & USART_ISR_FE)
 8000e78:	07a2      	lsls	r2, r4, #30
 8000e7a:	d501      	bpl.n	8000e80 <VectorAC+0x80>
    sts |= SD_FRAMING_ERROR;
 8000e7c:	2340      	movs	r3, #64	; 0x40
 8000e7e:	4319      	orrs	r1, r3
  if (isr & USART_ISR_NE)
 8000e80:	0763      	lsls	r3, r4, #29
 8000e82:	d502      	bpl.n	8000e8a <VectorAC+0x8a>
    sts |= SD_NOISE_ERROR;
 8000e84:	2380      	movs	r3, #128	; 0x80
 8000e86:	005b      	lsls	r3, r3, #1
 8000e88:	4319      	orrs	r1, r3
  chSysLockFromIsr();
 8000e8a:	b672      	cpsid	i
  chnAddFlagsI(sdp, sts);
 8000e8c:	1d30      	adds	r0, r6, #4
 8000e8e:	f000 f9e7 	bl	8001260 <chEvtBroadcastFlagsI>
  chSysUnlockFromIsr();
 8000e92:	b662      	cpsie	i
 8000e94:	e7bf      	b.n	8000e16 <VectorAC+0x16>
  }

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
    msg_t b;
    chSysLockFromIsr();
 8000e96:	b672      	cpsid	i
    b = chOQGetI(&sdp->oqueue);
 8000e98:	1c30      	adds	r0, r6, #0
 8000e9a:	3030      	adds	r0, #48	; 0x30
 8000e9c:	f000 fb40 	bl	8001520 <chOQGetI>
    if (b < Q_OK) {
 8000ea0:	2800      	cmp	r0, #0
 8000ea2:	db0b      	blt.n	8000ebc <VectorAC+0xbc>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->TDR = b;
 8000ea4:	b280      	uxth	r0, r0
 8000ea6:	8528      	strh	r0, [r5, #40]	; 0x28
    chSysUnlockFromIsr();
 8000ea8:	b662      	cpsie	i
 8000eaa:	e7bd      	b.n	8000e28 <VectorAC+0x28>
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
    chSysLockFromIsr();
    if (chOQIsEmptyI(&sdp->oqueue))
 8000eac:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 8000eae:	2b00      	cmp	r3, #0
 8000eb0:	d0c1      	beq.n	8000e36 <VectorAC+0x36>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 8000eb2:	1d30      	adds	r0, r6, #4
 8000eb4:	2110      	movs	r1, #16
 8000eb6:	f000 f9d3 	bl	8001260 <chEvtBroadcastFlagsI>
 8000eba:	e7bc      	b.n	8000e36 <VectorAC+0x36>
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
    msg_t b;
    chSysLockFromIsr();
    b = chOQGetI(&sdp->oqueue);
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 8000ebc:	1d30      	adds	r0, r6, #4
 8000ebe:	2108      	movs	r1, #8
 8000ec0:	f000 f9ce 	bl	8001260 <chEvtBroadcastFlagsI>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8000ec4:	23c0      	movs	r3, #192	; 0xc0
 8000ec6:	1c3a      	adds	r2, r7, #0
 8000ec8:	439a      	bics	r2, r3
 8000eca:	2340      	movs	r3, #64	; 0x40
 8000ecc:	4313      	orrs	r3, r2
 8000ece:	602b      	str	r3, [r5, #0]
 8000ed0:	e7ea      	b.n	8000ea8 <VectorAC+0xa8>
 8000ed2:	46c0      	nop			; (mov r8, r8)
 8000ed4:	20000c30 	.word	0x20000c30
 8000ed8:	46c0      	nop			; (mov r8, r8)
 8000eda:	46c0      	nop			; (mov r8, r8)
 8000edc:	46c0      	nop			; (mov r8, r8)
 8000ede:	46c0      	nop			; (mov r8, r8)

08000ee0 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 8000ee0:	b510      	push	{r4, lr}

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
 8000ee2:	4c05      	ldr	r4, [pc, #20]	; (8000ef8 <sd_lld_init+0x18>)
 8000ee4:	2100      	movs	r1, #0
 8000ee6:	1c20      	adds	r0, r4, #0
 8000ee8:	4a04      	ldr	r2, [pc, #16]	; (8000efc <sd_lld_init+0x1c>)
 8000eea:	f7ff fd11 	bl	8000910 <sdObjectInit>
  SD1.usart = USART1;
 8000eee:	4b04      	ldr	r3, [pc, #16]	; (8000f00 <sd_lld_init+0x20>)
 8000ef0:	6763      	str	r3, [r4, #116]	; 0x74
  SD1.clock = STM32_USART1CLK;
 8000ef2:	4b04      	ldr	r3, [pc, #16]	; (8000f04 <sd_lld_init+0x24>)
 8000ef4:	67a3      	str	r3, [r4, #120]	; 0x78
#if STM32_SERIAL_USE_USART6
  sdObjectInit(&SD6, NULL, notify6);
  SD6.usart = USART6;
  SD6.clock = STM32_USART6CLK;
#endif
}
 8000ef6:	bd10      	pop	{r4, pc}
 8000ef8:	20000c30 	.word	0x20000c30
 8000efc:	08000df1 	.word	0x08000df1
 8000f00:	40013800 	.word	0x40013800
 8000f04:	02dc6c00 	.word	0x02dc6c00
 8000f08:	46c0      	nop			; (mov r8, r8)
 8000f0a:	46c0      	nop			; (mov r8, r8)
 8000f0c:	46c0      	nop			; (mov r8, r8)
 8000f0e:	46c0      	nop			; (mov r8, r8)

08000f10 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 8000f10:	b570      	push	{r4, r5, r6, lr}
 8000f12:	1c06      	adds	r6, r0, #0
 8000f14:	1e0c      	subs	r4, r1, #0

  if (config == NULL)
 8000f16:	d028      	beq.n	8000f6a <sd_lld_start+0x5a>
    config = &default_config;

  if (sdp->state == SD_STOP) {
 8000f18:	7a33      	ldrb	r3, [r6, #8]
 8000f1a:	2b01      	cmp	r3, #1
 8000f1c:	d017      	beq.n	8000f4e <sd_lld_start+0x3e>
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;

  /* Baud rate setting.*/
  u->BRR = (uint16_t)(sdp->clock / config->speed);
 8000f1e:	6fb0      	ldr	r0, [r6, #120]	; 0x78
 8000f20:	6821      	ldr	r1, [r4, #0]
 8000f22:	f7ff f90d 	bl	8000140 <__aeabi_uidiv>

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8000f26:	68a2      	ldr	r2, [r4, #8]
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 8000f28:	6f75      	ldr	r5, [r6, #116]	; 0x74

  /* Baud rate setting.*/
  u->BRR = (uint16_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8000f2a:	2340      	movs	r3, #64	; 0x40
 8000f2c:	4313      	orrs	r3, r2
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;

  /* Baud rate setting.*/
  u->BRR = (uint16_t)(sdp->clock / config->speed);
 8000f2e:	b280      	uxth	r0, r0

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8000f30:	68e2      	ldr	r2, [r4, #12]
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;

  /* Baud rate setting.*/
  u->BRR = (uint16_t)(sdp->clock / config->speed);
 8000f32:	81a8      	strh	r0, [r5, #12]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8000f34:	606b      	str	r3, [r5, #4]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8000f36:	2301      	movs	r3, #1
 8000f38:	4313      	orrs	r3, r2
 8000f3a:	60ab      	str	r3, [r5, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8000f3c:	6862      	ldr	r2, [r4, #4]
 8000f3e:	232e      	movs	r3, #46	; 0x2e
 8000f40:	33ff      	adds	r3, #255	; 0xff
 8000f42:	4313      	orrs	r3, r2
  u->BRR = (uint16_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8000f44:	602b      	str	r3, [r5, #0]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFF;
 8000f46:	2301      	movs	r3, #1
 8000f48:	425b      	negs	r3, r3
 8000f4a:	622b      	str	r3, [r5, #32]
                       CORTEX_PRIORITY_MASK(STM32_SERIAL_USART6_PRIORITY));
    }
#endif
  }
  usart_init(sdp, config);
}
 8000f4c:	bd70      	pop	{r4, r5, r6, pc}
  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
 8000f4e:	4b08      	ldr	r3, [pc, #32]	; (8000f70 <sd_lld_start+0x60>)
 8000f50:	429e      	cmp	r6, r3
 8000f52:	d1e4      	bne.n	8000f1e <sd_lld_start+0xe>
      rccEnableUSART1(FALSE);
 8000f54:	4b07      	ldr	r3, [pc, #28]	; (8000f74 <sd_lld_start+0x64>)
 8000f56:	2280      	movs	r2, #128	; 0x80
 8000f58:	6999      	ldr	r1, [r3, #24]
 8000f5a:	01d2      	lsls	r2, r2, #7
 8000f5c:	430a      	orrs	r2, r1
 8000f5e:	619a      	str	r2, [r3, #24]
      nvicEnableVector(STM32_USART1_NUMBER,
 8000f60:	201b      	movs	r0, #27
 8000f62:	21c0      	movs	r1, #192	; 0xc0
 8000f64:	f000 f91c 	bl	80011a0 <nvicEnableVector>
 8000f68:	e7d9      	b.n	8000f1e <sd_lld_start+0xe>
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;
 8000f6a:	4c03      	ldr	r4, [pc, #12]	; (8000f78 <sd_lld_start+0x68>)
 8000f6c:	e7d4      	b.n	8000f18 <sd_lld_start+0x8>
 8000f6e:	46c0      	nop			; (mov r8, r8)
 8000f70:	20000c30 	.word	0x20000c30
 8000f74:	40021000 	.word	0x40021000
 8000f78:	08001640 	.word	0x08001640
 8000f7c:	46c0      	nop			; (mov r8, r8)
 8000f7e:	46c0      	nop			; (mov r8, r8)

08000f80 <Vector64>:
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(Vector64) {
 8000f80:	b510      	push	{r4, lr}
  uint32_t flags;

  CH_IRQ_PROLOGUE();
 8000f82:	4674      	mov	r4, lr

  flags = (DMA1->ISR >> 0) & STM32_DMA_ISR_MASK;
 8000f84:	4b07      	ldr	r3, [pc, #28]	; (8000fa4 <Vector64+0x24>)
 8000f86:	210f      	movs	r1, #15
 8000f88:	681a      	ldr	r2, [r3, #0]
 8000f8a:	4011      	ands	r1, r2
  DMA1->IFCR = flags << 0;
  if (dma_isr_redir[0].dma_func)
 8000f8c:	4a06      	ldr	r2, [pc, #24]	; (8000fa8 <Vector64+0x28>)
  uint32_t flags;

  CH_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 0) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = flags << 0;
 8000f8e:	6059      	str	r1, [r3, #4]
  if (dma_isr_redir[0].dma_func)
 8000f90:	6813      	ldr	r3, [r2, #0]
 8000f92:	2b00      	cmp	r3, #0
 8000f94:	d001      	beq.n	8000f9a <Vector64+0x1a>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
 8000f96:	6850      	ldr	r0, [r2, #4]
 8000f98:	4798      	blx	r3

  CH_IRQ_EPILOGUE();
 8000f9a:	1c20      	adds	r0, r4, #0
 8000f9c:	f000 f8a8 	bl	80010f0 <_port_irq_epilogue>
}
 8000fa0:	bd10      	pop	{r4, pc}
 8000fa2:	46c0      	nop			; (mov r8, r8)
 8000fa4:	40020000 	.word	0x40020000
 8000fa8:	20000cac 	.word	0x20000cac
 8000fac:	46c0      	nop			; (mov r8, r8)
 8000fae:	46c0      	nop			; (mov r8, r8)

08000fb0 <Vector68>:
/**
 * @brief   DMA1 streams 2 and 3 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(Vector68) {
 8000fb0:	b510      	push	{r4, lr}
  uint32_t flags;

  CH_IRQ_PROLOGUE();
 8000fb2:	4674      	mov	r4, lr

  /* Check on channel 2.*/
  flags = (DMA1->ISR >> 4) & STM32_DMA_ISR_MASK;
 8000fb4:	4b0e      	ldr	r3, [pc, #56]	; (8000ff0 <Vector68+0x40>)
 8000fb6:	6819      	ldr	r1, [r3, #0]
 8000fb8:	0609      	lsls	r1, r1, #24
 8000fba:	0f09      	lsrs	r1, r1, #28
  if (flags & STM32_DMA_ISR_MASK) {
 8000fbc:	d007      	beq.n	8000fce <Vector68+0x1e>
    DMA1->IFCR = flags << 4;
 8000fbe:	010a      	lsls	r2, r1, #4
 8000fc0:	605a      	str	r2, [r3, #4]
    if (dma_isr_redir[1].dma_func)
 8000fc2:	4a0c      	ldr	r2, [pc, #48]	; (8000ff4 <Vector68+0x44>)
 8000fc4:	6893      	ldr	r3, [r2, #8]
 8000fc6:	2b00      	cmp	r3, #0
 8000fc8:	d001      	beq.n	8000fce <Vector68+0x1e>
      dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
 8000fca:	68d0      	ldr	r0, [r2, #12]
 8000fcc:	4798      	blx	r3
  }

  /* Check on channel 3.*/
  flags = (DMA1->ISR >> 8) & STM32_DMA_ISR_MASK;
 8000fce:	4b08      	ldr	r3, [pc, #32]	; (8000ff0 <Vector68+0x40>)
 8000fd0:	6819      	ldr	r1, [r3, #0]
 8000fd2:	0509      	lsls	r1, r1, #20
 8000fd4:	0f09      	lsrs	r1, r1, #28
  if (flags & STM32_DMA_ISR_MASK) {
 8000fd6:	d007      	beq.n	8000fe8 <Vector68+0x38>
    DMA1->IFCR = flags << 8;
 8000fd8:	020a      	lsls	r2, r1, #8
 8000fda:	605a      	str	r2, [r3, #4]
    if (dma_isr_redir[2].dma_func)
 8000fdc:	4a05      	ldr	r2, [pc, #20]	; (8000ff4 <Vector68+0x44>)
 8000fde:	6913      	ldr	r3, [r2, #16]
 8000fe0:	2b00      	cmp	r3, #0
 8000fe2:	d001      	beq.n	8000fe8 <Vector68+0x38>
      dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
 8000fe4:	6950      	ldr	r0, [r2, #20]
 8000fe6:	4798      	blx	r3
  }

  CH_IRQ_EPILOGUE();
 8000fe8:	1c20      	adds	r0, r4, #0
 8000fea:	f000 f881 	bl	80010f0 <_port_irq_epilogue>
}
 8000fee:	bd10      	pop	{r4, pc}
 8000ff0:	40020000 	.word	0x40020000
 8000ff4:	20000cac 	.word	0x20000cac
 8000ff8:	46c0      	nop			; (mov r8, r8)
 8000ffa:	46c0      	nop			; (mov r8, r8)
 8000ffc:	46c0      	nop			; (mov r8, r8)
 8000ffe:	46c0      	nop			; (mov r8, r8)

08001000 <Vector6C>:
/**
 * @brief   DMA1 streams 4 and 5 shared interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(Vector6C) {
 8001000:	b510      	push	{r4, lr}
  uint32_t flags;

  CH_IRQ_PROLOGUE();
 8001002:	4674      	mov	r4, lr

  /* Check on channel 4.*/
  flags = (DMA1->ISR >> 12) & STM32_DMA_ISR_MASK;
 8001004:	4b0e      	ldr	r3, [pc, #56]	; (8001040 <Vector6C+0x40>)
 8001006:	6819      	ldr	r1, [r3, #0]
 8001008:	0409      	lsls	r1, r1, #16
 800100a:	0f09      	lsrs	r1, r1, #28
  if (flags & STM32_DMA_ISR_MASK) {
 800100c:	d007      	beq.n	800101e <Vector6C+0x1e>
    DMA1->IFCR = flags << 12;
 800100e:	030a      	lsls	r2, r1, #12
 8001010:	605a      	str	r2, [r3, #4]
    if (dma_isr_redir[3].dma_func)
 8001012:	4a0c      	ldr	r2, [pc, #48]	; (8001044 <Vector6C+0x44>)
 8001014:	6993      	ldr	r3, [r2, #24]
 8001016:	2b00      	cmp	r3, #0
 8001018:	d001      	beq.n	800101e <Vector6C+0x1e>
      dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
 800101a:	69d0      	ldr	r0, [r2, #28]
 800101c:	4798      	blx	r3
  }

  /* Check on channel 5.*/
  flags = (DMA1->ISR >> 16) & STM32_DMA_ISR_MASK;
 800101e:	4b08      	ldr	r3, [pc, #32]	; (8001040 <Vector6C+0x40>)
 8001020:	6819      	ldr	r1, [r3, #0]
 8001022:	0309      	lsls	r1, r1, #12
 8001024:	0f09      	lsrs	r1, r1, #28
  if (flags & STM32_DMA_ISR_MASK) {
 8001026:	d007      	beq.n	8001038 <Vector6C+0x38>
    DMA1->IFCR = flags << 16;
 8001028:	040a      	lsls	r2, r1, #16
 800102a:	605a      	str	r2, [r3, #4]
    if (dma_isr_redir[4].dma_func)
 800102c:	4a05      	ldr	r2, [pc, #20]	; (8001044 <Vector6C+0x44>)
 800102e:	6a13      	ldr	r3, [r2, #32]
 8001030:	2b00      	cmp	r3, #0
 8001032:	d001      	beq.n	8001038 <Vector6C+0x38>
      dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
 8001034:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8001036:	4798      	blx	r3
  }

  CH_IRQ_EPILOGUE();
 8001038:	1c20      	adds	r0, r4, #0
 800103a:	f000 f859 	bl	80010f0 <_port_irq_epilogue>
}
 800103e:	bd10      	pop	{r4, pc}
 8001040:	40020000 	.word	0x40020000
 8001044:	20000cac 	.word	0x20000cac
 8001048:	46c0      	nop			; (mov r8, r8)
 800104a:	46c0      	nop			; (mov r8, r8)
 800104c:	46c0      	nop			; (mov r8, r8)
 800104e:	46c0      	nop			; (mov r8, r8)

08001050 <dmaInit>:
 * @init
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
 8001050:	4a0b      	ldr	r2, [pc, #44]	; (8001080 <dmaInit+0x30>)
 8001052:	2300      	movs	r3, #0
 8001054:	6013      	str	r3, [r2, #0]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = 0;
 8001056:	4a0b      	ldr	r2, [pc, #44]	; (8001084 <dmaInit+0x34>)
 8001058:	490b      	ldr	r1, [pc, #44]	; (8001088 <dmaInit+0x38>)
 800105a:	6013      	str	r3, [r2, #0]
    dma_isr_redir[i].dma_func = NULL;
 800105c:	4a0b      	ldr	r2, [pc, #44]	; (800108c <dmaInit+0x3c>)
 800105e:	6013      	str	r3, [r2, #0]
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = 0;
 8001060:	600b      	str	r3, [r1, #0]
 8001062:	490b      	ldr	r1, [pc, #44]	; (8001090 <dmaInit+0x40>)
    dma_isr_redir[i].dma_func = NULL;
 8001064:	6093      	str	r3, [r2, #8]
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = 0;
 8001066:	600b      	str	r3, [r1, #0]
 8001068:	490a      	ldr	r1, [pc, #40]	; (8001094 <dmaInit+0x44>)
    dma_isr_redir[i].dma_func = NULL;
 800106a:	6113      	str	r3, [r2, #16]
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = 0;
 800106c:	600b      	str	r3, [r1, #0]
 800106e:	490a      	ldr	r1, [pc, #40]	; (8001098 <dmaInit+0x48>)
    dma_isr_redir[i].dma_func = NULL;
 8001070:	6193      	str	r3, [r2, #24]
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = 0;
 8001072:	600b      	str	r3, [r1, #0]
    dma_isr_redir[i].dma_func = NULL;
 8001074:	6213      	str	r3, [r2, #32]
  }
  DMA1->IFCR = 0xFFFFFFFF;
 8001076:	4b09      	ldr	r3, [pc, #36]	; (800109c <dmaInit+0x4c>)
 8001078:	2201      	movs	r2, #1
 800107a:	4252      	negs	r2, r2
 800107c:	605a      	str	r2, [r3, #4]
}
 800107e:	4770      	bx	lr
 8001080:	20000cd4 	.word	0x20000cd4
 8001084:	40020008 	.word	0x40020008
 8001088:	4002001c 	.word	0x4002001c
 800108c:	20000cac 	.word	0x20000cac
 8001090:	40020030 	.word	0x40020030
 8001094:	40020044 	.word	0x40020044
 8001098:	40020058 	.word	0x40020058
 800109c:	40020000 	.word	0x40020000

080010a0 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
 80010a0:	b508      	push	{r3, lr}

  stm32_clock_init();
 80010a2:	f7ff fccd 	bl	8000a40 <stm32_clock_init>
}
 80010a6:	bd08      	pop	{r3, pc}
 80010a8:	46c0      	nop			; (mov r8, r8)
 80010aa:	46c0      	nop			; (mov r8, r8)
 80010ac:	46c0      	nop			; (mov r8, r8)
 80010ae:	46c0      	nop			; (mov r8, r8)

080010b0 <boardInit>:
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
}
 80010b0:	4770      	bx	lr
 80010b2:	46c0      	nop			; (mov r8, r8)
 80010b4:	46c0      	nop			; (mov r8, r8)
 80010b6:	46c0      	nop			; (mov r8, r8)
 80010b8:	46c0      	nop			; (mov r8, r8)
 80010ba:	46c0      	nop			; (mov r8, r8)
 80010bc:	46c0      	nop			; (mov r8, r8)
 80010be:	46c0      	nop			; (mov r8, r8)

080010c0 <_port_switch_from_isr>:
__attribute__((naked))
#endif
void _port_switch_from_isr(void) {

  dbg_check_lock();
  chSchDoReschedule();
 80010c0:	f7ff fa5e 	bl	8000580 <chSchDoReschedule>

080010c4 <_port_exit_from_isr>:
  asm volatile ("_port_exit_from_isr:" : : : "memory");
#if CORTEX_ALTERNATE_SWITCH
  SCB_ICSR = ICSR_PENDSVSET;
  port_unlock();
#else
  SCB_ICSR = ICSR_NMIPENDSET;
 80010c4:	2280      	movs	r2, #128	; 0x80
 80010c6:	4b02      	ldr	r3, [pc, #8]	; (80010d0 <_port_exit_from_isr+0xc>)
 80010c8:	0612      	lsls	r2, r2, #24
 80010ca:	605a      	str	r2, [r3, #4]
 80010cc:	e7fe      	b.n	80010cc <_port_exit_from_isr+0x8>
 80010ce:	46c0      	nop			; (mov r8, r8)
 80010d0:	e000ed00 	.word	0xe000ed00
 80010d4:	46c0      	nop			; (mov r8, r8)
 80010d6:	46c0      	nop			; (mov r8, r8)
 80010d8:	46c0      	nop			; (mov r8, r8)
 80010da:	46c0      	nop			; (mov r8, r8)
 80010dc:	46c0      	nop			; (mov r8, r8)
 80010de:	46c0      	nop			; (mov r8, r8)

080010e0 <NMIVector>:
void NMIVector(void) {
  register struct extctx *ctxp;

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  asm volatile ("mrs     %0, PSP" : "=r" (ctxp) : : "memory");
 80010e0:	f3ef 8309 	mrs	r3, PSP
  ctxp++;
 80010e4:	3320      	adds	r3, #32
  asm volatile ("msr     PSP, %0" : : "r" (ctxp) : "memory");
 80010e6:	f383 8809 	msr	PSP, r3
  port_unlock_from_isr();
 80010ea:	b662      	cpsie	i
}
 80010ec:	4770      	bx	lr
 80010ee:	46c0      	nop			; (mov r8, r8)

080010f0 <_port_irq_epilogue>:
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {

  if (lr != (regarm_t)0xFFFFFFF1) {
 80010f0:	300f      	adds	r0, #15
 80010f2:	d019      	beq.n	8001128 <_port_irq_epilogue+0x38>
    register struct extctx *ctxp;

    port_lock_from_isr();
 80010f4:	b672      	cpsid	i
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    asm volatile ("mrs     %0, PSP" : "=r" (ctxp) : : "memory");
 80010f6:	f3ef 8309 	mrs	r3, PSP
    ctxp--;
 80010fa:	1c1a      	adds	r2, r3, #0
 80010fc:	3a20      	subs	r2, #32
    asm volatile ("msr     PSP, %0" : : "r" (ctxp) : "memory");
 80010fe:	f382 8809 	msr	PSP, r2
    ctxp->xpsr = (regarm_t)0x01000000;

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8001102:	480f      	ldr	r0, [pc, #60]	; (8001140 <_port_irq_epilogue+0x50>)
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    asm volatile ("mrs     %0, PSP" : "=r" (ctxp) : : "memory");
    ctxp--;
    asm volatile ("msr     PSP, %0" : : "r" (ctxp) : "memory");
    ctxp->xpsr = (regarm_t)0x01000000;
 8001104:	2280      	movs	r2, #128	; 0x80
 8001106:	0452      	lsls	r2, r2, #17
 8001108:	3b20      	subs	r3, #32

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 800110a:	6981      	ldr	r1, [r0, #24]
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    asm volatile ("mrs     %0, PSP" : "=r" (ctxp) : : "memory");
    ctxp--;
    asm volatile ("msr     PSP, %0" : : "r" (ctxp) : "memory");
    ctxp->xpsr = (regarm_t)0x01000000;
 800110c:	61da      	str	r2, [r3, #28]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 800110e:	7fca      	ldrb	r2, [r1, #31]
 8001110:	2a00      	cmp	r2, #0
 8001112:	d10a      	bne.n	800112a <_port_irq_epilogue+0x3a>
 8001114:	6800      	ldr	r0, [r0, #0]
 8001116:	6889      	ldr	r1, [r1, #8]
 8001118:	6880      	ldr	r0, [r0, #8]
 800111a:	4288      	cmp	r0, r1
 800111c:	4152      	adcs	r2, r2
 800111e:	b2d2      	uxtb	r2, r2
 8001120:	2a00      	cmp	r2, #0
 8001122:	d10a      	bne.n	800113a <_port_irq_epilogue+0x4a>
      ctxp->pc = (void *)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (void *)_port_exit_from_isr;
 8001124:	4a07      	ldr	r2, [pc, #28]	; (8001144 <_port_irq_epilogue+0x54>)
 8001126:	619a      	str	r2, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
  }
}
 8001128:	4770      	bx	lr
    asm volatile ("msr     PSP, %0" : : "r" (ctxp) : "memory");
    ctxp->xpsr = (regarm_t)0x01000000;

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 800112a:	6802      	ldr	r2, [r0, #0]
 800112c:	6889      	ldr	r1, [r1, #8]
 800112e:	6892      	ldr	r2, [r2, #8]
 8001130:	4291      	cmp	r1, r2
 8001132:	4192      	sbcs	r2, r2
 8001134:	4252      	negs	r2, r2
 8001136:	2a00      	cmp	r2, #0
 8001138:	d0f4      	beq.n	8001124 <_port_irq_epilogue+0x34>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (void *)_port_switch_from_isr;
 800113a:	4a03      	ldr	r2, [pc, #12]	; (8001148 <_port_irq_epilogue+0x58>)
 800113c:	619a      	str	r2, [r3, #24]
 800113e:	e7f3      	b.n	8001128 <_port_irq_epilogue+0x38>
 8001140:	20000aa0 	.word	0x20000aa0
 8001144:	080010c4 	.word	0x080010c4
 8001148:	080010c1 	.word	0x080010c1
 800114c:	46c0      	nop			; (mov r8, r8)
 800114e:	46c0      	nop			; (mov r8, r8)

08001150 <SysTickVector>:
/**
 * @brief   System Timer vector.
 * @details This interrupt is used as system tick.
 * @note    The timer must be initialized in the startup code.
 */
CH_IRQ_HANDLER(SysTickVector) {
 8001150:	b510      	push	{r4, lr}

  CH_IRQ_PROLOGUE();
 8001152:	4674      	mov	r4, lr

  chSysLockFromIsr();
 8001154:	b672      	cpsid	i
  chSysTimerHandlerI();
 8001156:	f7ff fa73 	bl	8000640 <chSysTimerHandlerI>
  chSysUnlockFromIsr();
 800115a:	b662      	cpsie	i

  CH_IRQ_EPILOGUE();
 800115c:	1c20      	adds	r0, r4, #0
 800115e:	f7ff ffc7 	bl	80010f0 <_port_irq_epilogue>
}
 8001162:	bd10      	pop	{r4, pc}
 8001164:	46c0      	nop			; (mov r8, r8)
 8001166:	46c0      	nop			; (mov r8, r8)
 8001168:	46c0      	nop			; (mov r8, r8)
 800116a:	46c0      	nop			; (mov r8, r8)
 800116c:	46c0      	nop			; (mov r8, r8)
 800116e:	46c0      	nop			; (mov r8, r8)

08001170 <_port_switch>:
__attribute__((naked))
#endif
void _port_switch(Thread *ntp, Thread *otp) {
  register struct intctx *r13 asm ("r13");

  asm volatile ("push    {r4, r5, r6, r7, lr}                   \n\t"
 8001170:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001172:	4644      	mov	r4, r8
 8001174:	464d      	mov	r5, r9
 8001176:	4656      	mov	r6, sl
 8001178:	465f      	mov	r7, fp
 800117a:	b4f0      	push	{r4, r5, r6, r7}
                "mov     r5, r9                                 \n\t"
                "mov     r6, r10                                \n\t"
                "mov     r7, r11                                \n\t"
                "push    {r4, r5, r6, r7}" : : : "memory");

  otp->p_ctx.r13 = r13;
 800117c:	466b      	mov	r3, sp
 800117e:	60cb      	str	r3, [r1, #12]
  r13 = ntp->p_ctx.r13;
 8001180:	68c3      	ldr	r3, [r0, #12]
 8001182:	469d      	mov	sp, r3

  asm volatile ("pop     {r4, r5, r6, r7}                       \n\t"
 8001184:	bcf0      	pop	{r4, r5, r6, r7}
 8001186:	46a0      	mov	r8, r4
 8001188:	46a9      	mov	r9, r5
 800118a:	46b2      	mov	sl, r6
 800118c:	46bb      	mov	fp, r7
 800118e:	bdf0      	pop	{r4, r5, r6, r7, pc}

08001190 <_port_thread_start>:
 * @details If the work function returns @p chThdExit() is automatically
 *          invoked.
 */
void _port_thread_start(void) {

  chSysUnlock();
 8001190:	b662      	cpsie	i
  asm volatile ("mov     r0, r5                                 \n\t"
 8001192:	1c28      	adds	r0, r5, #0
 8001194:	47a0      	blx	r4
 8001196:	f7ff fafb 	bl	8000790 <chThdExit>
                "blx     r4                                     \n\t"
                "bl      chThdExit");
}
 800119a:	4770      	bx	lr
 800119c:	46c0      	nop			; (mov r8, r8)
 800119e:	46c0      	nop			; (mov r8, r8)

080011a0 <nvicEnableVector>:
 * @param[in] prio      the interrupt priority mask
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
  unsigned sh = (n & 3) << 3;

  NVIC_IPR(n >> 2) = (NVIC_IPR(n >> 2) & ~(0xFF << sh)) | (prio << sh);
 80011a0:	0882      	lsrs	r2, r0, #2
 80011a2:	4b0f      	ldr	r3, [pc, #60]	; (80011e0 <nvicEnableVector+0x40>)
 80011a4:	0092      	lsls	r2, r2, #2
 * @note    The parameters are not tested for correctness.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority mask
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 80011a6:	b570      	push	{r4, r5, r6, lr}
 80011a8:	18d2      	adds	r2, r2, r3
  unsigned sh = (n & 3) << 3;
 80011aa:	2403      	movs	r4, #3

  NVIC_IPR(n >> 2) = (NVIC_IPR(n >> 2) & ~(0xFF << sh)) | (prio << sh);
 80011ac:	23c0      	movs	r3, #192	; 0xc0
 80011ae:	009b      	lsls	r3, r3, #2
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority mask
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
  unsigned sh = (n & 3) << 3;
 80011b0:	4004      	ands	r4, r0

  NVIC_IPR(n >> 2) = (NVIC_IPR(n >> 2) & ~(0xFF << sh)) | (prio << sh);
 80011b2:	58d5      	ldr	r5, [r2, r3]
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority mask
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
  unsigned sh = (n & 3) << 3;
 80011b4:	00e4      	lsls	r4, r4, #3

  NVIC_IPR(n >> 2) = (NVIC_IPR(n >> 2) & ~(0xFF << sh)) | (prio << sh);
 80011b6:	26ff      	movs	r6, #255	; 0xff
 80011b8:	40a6      	lsls	r6, r4
 80011ba:	43b5      	bics	r5, r6
 80011bc:	40a1      	lsls	r1, r4
 80011be:	1c2c      	adds	r4, r5, #0
 80011c0:	430c      	orrs	r4, r1
 80011c2:	50d4      	str	r4, [r2, r3]
  NVIC_ICPR(n >> 5) = 1 << (n & 0x1F);
 80011c4:	231f      	movs	r3, #31
 80011c6:	4003      	ands	r3, r0
 80011c8:	2201      	movs	r2, #1
 80011ca:	409a      	lsls	r2, r3
 80011cc:	1c13      	adds	r3, r2, #0
 80011ce:	0940      	lsrs	r0, r0, #5
 80011d0:	4a03      	ldr	r2, [pc, #12]	; (80011e0 <nvicEnableVector+0x40>)
 80011d2:	0080      	lsls	r0, r0, #2
 80011d4:	1880      	adds	r0, r0, r2
 80011d6:	22c0      	movs	r2, #192	; 0xc0
 80011d8:	0052      	lsls	r2, r2, #1
 80011da:	5083      	str	r3, [r0, r2]
  NVIC_ISER(n >> 5) = 1 << (n & 0x1F);
 80011dc:	6003      	str	r3, [r0, #0]
}
 80011de:	bd70      	pop	{r4, r5, r6, pc}
 80011e0:	e000e100 	.word	0xe000e100
 80011e4:	46c0      	nop			; (mov r8, r8)
 80011e6:	46c0      	nop			; (mov r8, r8)
 80011e8:	46c0      	nop			; (mov r8, r8)
 80011ea:	46c0      	nop			; (mov r8, r8)
 80011ec:	46c0      	nop			; (mov r8, r8)
 80011ee:	46c0      	nop			; (mov r8, r8)

080011f0 <nvicSetSystemHandlerPriority>:
 * @param[in] prio      the system handler priority mask
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
  unsigned sh = (handler & 3) * 8;

  SCB_SHPR(handler >> 2) = (SCB_SHPR(handler >> 2) &
 80011f0:	0883      	lsrs	r3, r0, #2
 80011f2:	4a08      	ldr	r2, [pc, #32]	; (8001214 <nvicSetSystemHandlerPriority+0x24>)
 * @note    The parameters are not tested for correctness.
 *
 * @param[in] handler   the system handler number
 * @param[in] prio      the system handler priority mask
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
 80011f4:	b510      	push	{r4, lr}
 80011f6:	009b      	lsls	r3, r3, #2
  unsigned sh = (handler & 3) * 8;
 80011f8:	2403      	movs	r4, #3
 80011fa:	189b      	adds	r3, r3, r2
 80011fc:	4020      	ands	r0, r4

  SCB_SHPR(handler >> 2) = (SCB_SHPR(handler >> 2) &
 80011fe:	699a      	ldr	r2, [r3, #24]
 *
 * @param[in] handler   the system handler number
 * @param[in] prio      the system handler priority mask
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
  unsigned sh = (handler & 3) * 8;
 8001200:	00c0      	lsls	r0, r0, #3

  SCB_SHPR(handler >> 2) = (SCB_SHPR(handler >> 2) &
                           ~(0xFF << sh)) | (prio << sh);
 8001202:	24ff      	movs	r4, #255	; 0xff
 8001204:	4084      	lsls	r4, r0
 * @param[in] prio      the system handler priority mask
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
  unsigned sh = (handler & 3) * 8;

  SCB_SHPR(handler >> 2) = (SCB_SHPR(handler >> 2) &
 8001206:	43a2      	bics	r2, r4
                           ~(0xFF << sh)) | (prio << sh);
 8001208:	4081      	lsls	r1, r0
 800120a:	1c10      	adds	r0, r2, #0
 800120c:	4308      	orrs	r0, r1
 * @param[in] prio      the system handler priority mask
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
  unsigned sh = (handler & 3) * 8;

  SCB_SHPR(handler >> 2) = (SCB_SHPR(handler >> 2) &
 800120e:	6198      	str	r0, [r3, #24]
                           ~(0xFF << sh)) | (prio << sh);
}
 8001210:	bd10      	pop	{r4, pc}
 8001212:	46c0      	nop			; (mov r8, r8)
 8001214:	e000ed00 	.word	0xe000ed00
 8001218:	46c0      	nop			; (mov r8, r8)
 800121a:	46c0      	nop			; (mov r8, r8)
 800121c:	46c0      	nop			; (mov r8, r8)
 800121e:	46c0      	nop			; (mov r8, r8)

08001220 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] mask      the event flags set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(Thread *tp, eventmask_t mask) {
 8001220:	b508      	push	{r3, lr}

  chDbgCheckClassI();
  chDbgCheck(tp != NULL, "chEvtSignalI");

  tp->p_epending |= mask;
 8001222:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8001224:	4319      	orrs	r1, r3
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
 8001226:	7f03      	ldrb	r3, [r0, #28]
void chEvtSignalI(Thread *tp, eventmask_t mask) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL, "chEvtSignalI");

  tp->p_epending |= mask;
 8001228:	6381      	str	r1, [r0, #56]	; 0x38
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
 800122a:	2b08      	cmp	r3, #8
 800122c:	d00b      	beq.n	8001246 <chEvtSignalI+0x26>
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
 800122e:	2b09      	cmp	r3, #9
 8001230:	d000      	beq.n	8001234 <chEvtSignalI+0x14>
      ((tp->p_state == THD_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask)))
    chSchReadyI(tp)->p_u.rdymsg = RDY_OK;
}
 8001232:	bd08      	pop	{r3, pc}
  tp->p_epending |= mask;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
      ((tp->p_state == THD_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask)))
 8001234:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001236:	4019      	ands	r1, r3

  tp->p_epending |= mask;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
      ((tp->p_state == THD_STATE_WTANDEVT) &&
 8001238:	428b      	cmp	r3, r1
 800123a:	d1fa      	bne.n	8001232 <chEvtSignalI+0x12>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask)))
    chSchReadyI(tp)->p_u.rdymsg = RDY_OK;
 800123c:	f7ff f8f0 	bl	8000420 <chSchReadyI>
 8001240:	2300      	movs	r3, #0
 8001242:	6243      	str	r3, [r0, #36]	; 0x24
 8001244:	e7f5      	b.n	8001232 <chEvtSignalI+0x12>
  chDbgCheckClassI();
  chDbgCheck(tp != NULL, "chEvtSignalI");

  tp->p_epending |= mask;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == THD_STATE_WTOREVT) &&
 8001246:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001248:	420b      	tst	r3, r1
 800124a:	d0f2      	beq.n	8001232 <chEvtSignalI+0x12>
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
      ((tp->p_state == THD_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask)))
    chSchReadyI(tp)->p_u.rdymsg = RDY_OK;
 800124c:	f7ff f8e8 	bl	8000420 <chSchReadyI>
 8001250:	2300      	movs	r3, #0
 8001252:	6243      	str	r3, [r0, #36]	; 0x24
 8001254:	e7ed      	b.n	8001232 <chEvtSignalI+0x12>
 8001256:	46c0      	nop			; (mov r8, r8)
 8001258:	46c0      	nop			; (mov r8, r8)
 800125a:	46c0      	nop			; (mov r8, r8)
 800125c:	46c0      	nop			; (mov r8, r8)
 800125e:	46c0      	nop			; (mov r8, r8)

08001260 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p EventSource structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(EventSource *esp, flagsmask_t flags) {
 8001260:	b570      	push	{r4, r5, r6, lr}
  EventListener *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL, "chEvtBroadcastMaskI");

  elp = esp->es_next;
 8001262:	6804      	ldr	r4, [r0, #0]
 * @param[in] esp       pointer to the @p EventSource structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(EventSource *esp, flagsmask_t flags) {
 8001264:	1c05      	adds	r5, r0, #0
 8001266:	1c0e      	adds	r6, r1, #0

  chDbgCheckClassI();
  chDbgCheck(esp != NULL, "chEvtBroadcastMaskI");

  elp = esp->es_next;
  while (elp != (EventListener *)esp) {
 8001268:	42a0      	cmp	r0, r4
 800126a:	d009      	beq.n	8001280 <chEvtBroadcastFlagsI+0x20>
    elp->el_flags |= flags;
 800126c:	68e3      	ldr	r3, [r4, #12]
    chEvtSignalI(elp->el_listener, elp->el_mask);
 800126e:	6860      	ldr	r0, [r4, #4]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL, "chEvtBroadcastMaskI");

  elp = esp->es_next;
  while (elp != (EventListener *)esp) {
    elp->el_flags |= flags;
 8001270:	4333      	orrs	r3, r6
 8001272:	60e3      	str	r3, [r4, #12]
    chEvtSignalI(elp->el_listener, elp->el_mask);
 8001274:	68a1      	ldr	r1, [r4, #8]
 8001276:	f7ff ffd3 	bl	8001220 <chEvtSignalI>
    elp = elp->el_next;
 800127a:	6824      	ldr	r4, [r4, #0]

  chDbgCheckClassI();
  chDbgCheck(esp != NULL, "chEvtBroadcastMaskI");

  elp = esp->es_next;
  while (elp != (EventListener *)esp) {
 800127c:	42a5      	cmp	r5, r4
 800127e:	d1f5      	bne.n	800126c <chEvtBroadcastFlagsI+0xc>
    elp->el_flags |= flags;
    chEvtSignalI(elp->el_listener, elp->el_mask);
    elp = elp->el_next;
  }
}
 8001280:	bd70      	pop	{r4, r5, r6, pc}
 8001282:	46c0      	nop			; (mov r8, r8)
 8001284:	46c0      	nop			; (mov r8, r8)
 8001286:	46c0      	nop			; (mov r8, r8)
 8001288:	46c0      	nop			; (mov r8, r8)
 800128a:	46c0      	nop			; (mov r8, r8)
 800128c:	46c0      	nop			; (mov r8, r8)
 800128e:	46c0      	nop			; (mov r8, r8)

08001290 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
 8001290:	b508      	push	{r3, lr}
  default_heap.h_provider = chCoreAlloc;
 8001292:	4805      	ldr	r0, [pc, #20]	; (80012a8 <_heap_init+0x18>)
 8001294:	4b05      	ldr	r3, [pc, #20]	; (80012ac <_heap_init+0x1c>)
 8001296:	6003      	str	r3, [r0, #0]
  default_heap.h_free.h.u.next = (union heap_header *)NULL;
 8001298:	2300      	movs	r3, #0
 800129a:	6083      	str	r3, [r0, #8]
  default_heap.h_free.h.size = 0;
 800129c:	60c3      	str	r3, [r0, #12]
#if CH_USE_MUTEXES || defined(__DOXYGEN__)
  chMtxInit(&default_heap.h_mtx);
 800129e:	3010      	adds	r0, #16
 80012a0:	f000 f856 	bl	8001350 <chMtxInit>
#else
  chSemInit(&default_heap.h_sem, 1);
#endif
}
 80012a4:	bd08      	pop	{r3, pc}
 80012a6:	46c0      	nop			; (mov r8, r8)
 80012a8:	20000cd8 	.word	0x20000cd8
 80012ac:	08001321 	.word	0x08001321

080012b0 <queue_insert>:
 * @notapi
 */
void queue_insert(Thread *tp, ThreadsQueue *tqp) {

  tp->p_next = (Thread *)tqp;
  tp->p_prev = tqp->p_prev;
 80012b0:	684b      	ldr	r3, [r1, #4]
 *
 * @notapi
 */
void queue_insert(Thread *tp, ThreadsQueue *tqp) {

  tp->p_next = (Thread *)tqp;
 80012b2:	6001      	str	r1, [r0, #0]
  tp->p_prev = tqp->p_prev;
 80012b4:	6043      	str	r3, [r0, #4]
  tp->p_prev->p_next = tqp->p_prev = tp;
 80012b6:	6048      	str	r0, [r1, #4]
 80012b8:	6018      	str	r0, [r3, #0]
}
 80012ba:	4770      	bx	lr
 80012bc:	46c0      	nop			; (mov r8, r8)
 80012be:	46c0      	nop			; (mov r8, r8)

080012c0 <fifo_remove>:
 * @param[in] tqp       the pointer to the threads list header
 * @return              The removed thread pointer.
 *
 * @notapi
 */
Thread *fifo_remove(ThreadsQueue *tqp) {
 80012c0:	1c03      	adds	r3, r0, #0
  Thread *tp = tqp->p_next;
 80012c2:	6800      	ldr	r0, [r0, #0]

  (tqp->p_next = tp->p_next)->p_prev = (Thread *)tqp;
 80012c4:	6802      	ldr	r2, [r0, #0]
 80012c6:	601a      	str	r2, [r3, #0]
 80012c8:	6053      	str	r3, [r2, #4]
  return tp;
}
 80012ca:	4770      	bx	lr
 80012cc:	46c0      	nop			; (mov r8, r8)
 80012ce:	46c0      	nop			; (mov r8, r8)

080012d0 <dequeue>:
 *
 * @notapi
 */
Thread *dequeue(Thread *tp) {

  tp->p_prev->p_next = tp->p_next;
 80012d0:	6802      	ldr	r2, [r0, #0]
 80012d2:	6843      	ldr	r3, [r0, #4]
 80012d4:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 80012d6:	6802      	ldr	r2, [r0, #0]
 80012d8:	6053      	str	r3, [r2, #4]
  return tp;
}
 80012da:	4770      	bx	lr
 80012dc:	46c0      	nop			; (mov r8, r8)
 80012de:	46c0      	nop			; (mov r8, r8)

080012e0 <list_remove>:
 *
 * @notapi
 */
Thread *list_remove(ThreadsList *tlp) {

  Thread *tp = tlp->p_next;
 80012e0:	6803      	ldr	r3, [r0, #0]
  tlp->p_next = tp->p_next;
 80012e2:	681a      	ldr	r2, [r3, #0]
 80012e4:	6002      	str	r2, [r0, #0]
  return tp;
}
 80012e6:	1c18      	adds	r0, r3, #0
 80012e8:	4770      	bx	lr
 80012ea:	46c0      	nop			; (mov r8, r8)
 80012ec:	46c0      	nop			; (mov r8, r8)
 80012ee:	46c0      	nop			; (mov r8, r8)

080012f0 <_core_init>:
 */
void _core_init(void) {
#if CH_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 80012f0:	4905      	ldr	r1, [pc, #20]	; (8001308 <_core_init+0x18>)
 80012f2:	2307      	movs	r3, #7
 80012f4:	4a05      	ldr	r2, [pc, #20]	; (800130c <_core_init+0x1c>)
 80012f6:	3107      	adds	r1, #7
 80012f8:	4399      	bics	r1, r3
 80012fa:	6011      	str	r1, [r2, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 80012fc:	4a04      	ldr	r2, [pc, #16]	; (8001310 <_core_init+0x20>)
 80012fe:	439a      	bics	r2, r3
 8001300:	4b04      	ldr	r3, [pc, #16]	; (8001314 <_core_init+0x24>)
 8001302:	601a      	str	r2, [r3, #0]
#else
  static stkalign_t buffer[MEM_ALIGN_NEXT(CH_MEMCORE_SIZE)/MEM_ALIGN_SIZE];
  nextmem = (uint8_t *)&buffer[0];
  endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_MEMCORE_SIZE)/MEM_ALIGN_SIZE];
#endif
}
 8001304:	4770      	bx	lr
 8001306:	46c0      	nop			; (mov r8, r8)
 8001308:	20000d00 	.word	0x20000d00
 800130c:	20000cfc 	.word	0x20000cfc
 8001310:	20002000 	.word	0x20002000
 8001314:	20000cf8 	.word	0x20000cf8
 8001318:	46c0      	nop			; (mov r8, r8)
 800131a:	46c0      	nop			; (mov r8, r8)
 800131c:	46c0      	nop			; (mov r8, r8)
 800131e:	46c0      	nop			; (mov r8, r8)

08001320 <chCoreAlloc>:
 * @api
 */
void *chCoreAlloc(size_t size) {
  void *p;

  chSysLock();
 8001320:	b672      	cpsid	i
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 8001322:	2307      	movs	r3, #7
 8001324:	1dc2      	adds	r2, r0, #7
 8001326:	439a      	bics	r2, r3
  if ((size_t)(endmem - nextmem) < size)
 8001328:	4906      	ldr	r1, [pc, #24]	; (8001344 <chCoreAlloc+0x24>)
 800132a:	4b07      	ldr	r3, [pc, #28]	; (8001348 <chCoreAlloc+0x28>)
 800132c:	6809      	ldr	r1, [r1, #0]
 800132e:	6818      	ldr	r0, [r3, #0]
 8001330:	1a09      	subs	r1, r1, r0
 8001332:	428a      	cmp	r2, r1
 8001334:	d803      	bhi.n	800133e <chCoreAlloc+0x1e>
    return NULL;
  p = nextmem;
  nextmem += size;
 8001336:	1882      	adds	r2, r0, r2
 8001338:	601a      	str	r2, [r3, #0]
void *chCoreAlloc(size_t size) {
  void *p;

  chSysLock();
  p = chCoreAllocI(size);
  chSysUnlock();
 800133a:	b662      	cpsie	i
  return p;
}
 800133c:	4770      	bx	lr

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  if ((size_t)(endmem - nextmem) < size)
    return NULL;
 800133e:	2000      	movs	r0, #0
 8001340:	e7fb      	b.n	800133a <chCoreAlloc+0x1a>
 8001342:	46c0      	nop			; (mov r8, r8)
 8001344:	20000cf8 	.word	0x20000cf8
 8001348:	20000cfc 	.word	0x20000cfc
 800134c:	46c0      	nop			; (mov r8, r8)
 800134e:	46c0      	nop			; (mov r8, r8)

08001350 <chMtxInit>:
void chMtxInit(Mutex *mp) {

  chDbgCheck(mp != NULL, "chMtxInit");

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 8001350:	2300      	movs	r3, #0
 */
void chMtxInit(Mutex *mp) {

  chDbgCheck(mp != NULL, "chMtxInit");

  queue_init(&mp->m_queue);
 8001352:	6040      	str	r0, [r0, #4]
 8001354:	6000      	str	r0, [r0, #0]
  mp->m_owner = NULL;
 8001356:	6083      	str	r3, [r0, #8]
}
 8001358:	4770      	bx	lr
 800135a:	46c0      	nop			; (mov r8, r8)
 800135c:	46c0      	nop			; (mov r8, r8)
 800135e:	46c0      	nop			; (mov r8, r8)

08001360 <qwait>:
 *                      released from threads queue.
 * @retval Q_OK         is the normal exit, thread signaled.
 * @retval Q_RESET      if the queue has been reset.
 * @retval Q_TIMEOUT    if the queue operation timed out.
 */
static msg_t qwait(GenericQueue *qp, systime_t time) {
 8001360:	b510      	push	{r4, lr}
 8001362:	1c03      	adds	r3, r0, #0
 8001364:	1e0c      	subs	r4, r1, #0

  if (TIME_IMMEDIATE == time)
 8001366:	d00a      	beq.n	800137e <qwait+0x1e>
    return Q_TIMEOUT;
  currp->p_u.wtobjp = qp;
 8001368:	4a06      	ldr	r2, [pc, #24]	; (8001384 <qwait+0x24>)
  queue_insert(currp, &qp->q_waiting);
 800136a:	1c19      	adds	r1, r3, #0
 */
static msg_t qwait(GenericQueue *qp, systime_t time) {

  if (TIME_IMMEDIATE == time)
    return Q_TIMEOUT;
  currp->p_u.wtobjp = qp;
 800136c:	6990      	ldr	r0, [r2, #24]
 800136e:	6243      	str	r3, [r0, #36]	; 0x24
  queue_insert(currp, &qp->q_waiting);
 8001370:	f7ff ff9e 	bl	80012b0 <queue_insert>
  return chSchGoSleepTimeoutS(THD_STATE_WTQUEUE, time);
 8001374:	200d      	movs	r0, #13
 8001376:	1c21      	adds	r1, r4, #0
 8001378:	f7ff f87a 	bl	8000470 <chSchGoSleepTimeoutS>
}
 800137c:	bd10      	pop	{r4, pc}
 * @retval Q_TIMEOUT    if the queue operation timed out.
 */
static msg_t qwait(GenericQueue *qp, systime_t time) {

  if (TIME_IMMEDIATE == time)
    return Q_TIMEOUT;
 800137e:	2001      	movs	r0, #1
 8001380:	4240      	negs	r0, r0
 8001382:	e7fb      	b.n	800137c <qwait+0x1c>
 8001384:	20000aa0 	.word	0x20000aa0
 8001388:	46c0      	nop			; (mov r8, r8)
 800138a:	46c0      	nop			; (mov r8, r8)
 800138c:	46c0      	nop			; (mov r8, r8)
 800138e:	46c0      	nop			; (mov r8, r8)

08001390 <chIQInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQInit(InputQueue *iqp, uint8_t *bp, size_t size, qnotify_t infy,
              void *link) {
 8001390:	b510      	push	{r4, lr}

  queue_init(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer = iqp->q_rdptr = iqp->q_wrptr = bp;
  iqp->q_top = bp + size;
  iqp->q_notify = infy;
 8001392:	61c3      	str	r3, [r0, #28]
  iqp->q_link = link;
 8001394:	9b02      	ldr	r3, [sp, #8]
 */
void chIQInit(InputQueue *iqp, uint8_t *bp, size_t size, qnotify_t infy,
              void *link) {

  queue_init(&iqp->q_waiting);
  iqp->q_counter = 0;
 8001396:	2400      	movs	r4, #0
  iqp->q_buffer = iqp->q_rdptr = iqp->q_wrptr = bp;
 8001398:	6141      	str	r1, [r0, #20]
 800139a:	6181      	str	r1, [r0, #24]
 800139c:	60c1      	str	r1, [r0, #12]
  iqp->q_top = bp + size;
 800139e:	1889      	adds	r1, r1, r2
 * @init
 */
void chIQInit(InputQueue *iqp, uint8_t *bp, size_t size, qnotify_t infy,
              void *link) {

  queue_init(&iqp->q_waiting);
 80013a0:	6040      	str	r0, [r0, #4]
 80013a2:	6000      	str	r0, [r0, #0]
  iqp->q_counter = 0;
 80013a4:	6084      	str	r4, [r0, #8]
  iqp->q_buffer = iqp->q_rdptr = iqp->q_wrptr = bp;
  iqp->q_top = bp + size;
 80013a6:	6101      	str	r1, [r0, #16]
  iqp->q_notify = infy;
  iqp->q_link = link;
 80013a8:	6203      	str	r3, [r0, #32]
}
 80013aa:	bd10      	pop	{r4, pc}
 80013ac:	46c0      	nop			; (mov r8, r8)
 80013ae:	46c0      	nop			; (mov r8, r8)

080013b0 <chIQPutI>:
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(InputQueue *iqp, uint8_t b) {
 80013b0:	b508      	push	{r3, lr}

  chDbgCheckClassI();

  if (chIQIsFullI(iqp))
 80013b2:	6982      	ldr	r2, [r0, #24]
 80013b4:	6943      	ldr	r3, [r0, #20]
 80013b6:	4293      	cmp	r3, r2
 80013b8:	d01b      	beq.n	80013f2 <chIQPutI+0x42>
 80013ba:	6882      	ldr	r2, [r0, #8]
    return Q_FULL;

  iqp->q_counter++;
 80013bc:	3201      	adds	r2, #1
 80013be:	6082      	str	r2, [r0, #8]
  *iqp->q_wrptr++ = b;
 80013c0:	1c5a      	adds	r2, r3, #1
 80013c2:	6142      	str	r2, [r0, #20]
 80013c4:	7019      	strb	r1, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top)
 80013c6:	6943      	ldr	r3, [r0, #20]
 80013c8:	6902      	ldr	r2, [r0, #16]
 80013ca:	4293      	cmp	r3, r2
 80013cc:	d20a      	bcs.n	80013e4 <chIQPutI+0x34>
    iqp->q_wrptr = iqp->q_buffer;

  if (notempty(&iqp->q_waiting))
 80013ce:	6802      	ldr	r2, [r0, #0]
 80013d0:	4282      	cmp	r2, r0
 80013d2:	d00c      	beq.n	80013ee <chIQPutI+0x3e>
    chSchReadyI(fifo_remove(&iqp->q_waiting))->p_u.rdymsg = Q_OK;
 80013d4:	f7ff ff74 	bl	80012c0 <fifo_remove>
 80013d8:	f7ff f822 	bl	8000420 <chSchReadyI>
 80013dc:	2300      	movs	r3, #0
 80013de:	6243      	str	r3, [r0, #36]	; 0x24

  return Q_OK;
 80013e0:	2000      	movs	r0, #0
}
 80013e2:	bd08      	pop	{r3, pc}
    return Q_FULL;

  iqp->q_counter++;
  *iqp->q_wrptr++ = b;
  if (iqp->q_wrptr >= iqp->q_top)
    iqp->q_wrptr = iqp->q_buffer;
 80013e4:	68c3      	ldr	r3, [r0, #12]

  if (notempty(&iqp->q_waiting))
 80013e6:	6802      	ldr	r2, [r0, #0]
    return Q_FULL;

  iqp->q_counter++;
  *iqp->q_wrptr++ = b;
  if (iqp->q_wrptr >= iqp->q_top)
    iqp->q_wrptr = iqp->q_buffer;
 80013e8:	6143      	str	r3, [r0, #20]

  if (notempty(&iqp->q_waiting))
 80013ea:	4282      	cmp	r2, r0
 80013ec:	d1f2      	bne.n	80013d4 <chIQPutI+0x24>
    chSchReadyI(fifo_remove(&iqp->q_waiting))->p_u.rdymsg = Q_OK;

  return Q_OK;
 80013ee:	2000      	movs	r0, #0
 80013f0:	e7f7      	b.n	80013e2 <chIQPutI+0x32>
 */
msg_t chIQPutI(InputQueue *iqp, uint8_t b) {

  chDbgCheckClassI();

  if (chIQIsFullI(iqp))
 80013f2:	6882      	ldr	r2, [r0, #8]
 80013f4:	2a00      	cmp	r2, #0
 80013f6:	d0e1      	beq.n	80013bc <chIQPutI+0xc>
    return Q_FULL;
 80013f8:	2004      	movs	r0, #4
 80013fa:	4240      	negs	r0, r0
 80013fc:	e7f1      	b.n	80013e2 <chIQPutI+0x32>
 80013fe:	46c0      	nop			; (mov r8, r8)

08001400 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(InputQueue *iqp, systime_t time) {
 8001400:	b538      	push	{r3, r4, r5, lr}
 8001402:	1c04      	adds	r4, r0, #0
 8001404:	1c0d      	adds	r5, r1, #0
  uint8_t b;

  chSysLock();
 8001406:	b672      	cpsid	i
  if (iqp->q_notify)
 8001408:	69c3      	ldr	r3, [r0, #28]
 800140a:	2b00      	cmp	r3, #0
 800140c:	d007      	beq.n	800141e <chIQGetTimeout+0x1e>
    iqp->q_notify(iqp);
 800140e:	4798      	blx	r3
 8001410:	e005      	b.n	800141e <chIQGetTimeout+0x1e>

  while (chIQIsEmptyI(iqp)) {
    msg_t msg;
    if ((msg = qwait((GenericQueue *)iqp, time)) < Q_OK) {
 8001412:	1c20      	adds	r0, r4, #0
 8001414:	1c29      	adds	r1, r5, #0
 8001416:	f7ff ffa3 	bl	8001360 <qwait>
 800141a:	2800      	cmp	r0, #0
 800141c:	db0d      	blt.n	800143a <chIQGetTimeout+0x3a>

  chSysLock();
  if (iqp->q_notify)
    iqp->q_notify(iqp);

  while (chIQIsEmptyI(iqp)) {
 800141e:	68a3      	ldr	r3, [r4, #8]
 8001420:	2b00      	cmp	r3, #0
 8001422:	d0f6      	beq.n	8001412 <chIQGetTimeout+0x12>
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8001424:	69a2      	ldr	r2, [r4, #24]
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8001426:	3b01      	subs	r3, #1
 8001428:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 800142a:	1c53      	adds	r3, r2, #1
 800142c:	61a3      	str	r3, [r4, #24]
 800142e:	7810      	ldrb	r0, [r2, #0]
  if (iqp->q_rdptr >= iqp->q_top)
 8001430:	6922      	ldr	r2, [r4, #16]
 8001432:	4293      	cmp	r3, r2
 8001434:	d301      	bcc.n	800143a <chIQGetTimeout+0x3a>
    iqp->q_rdptr = iqp->q_buffer;
 8001436:	68e3      	ldr	r3, [r4, #12]
 8001438:	61a3      	str	r3, [r4, #24]

  chSysUnlock();
 800143a:	b662      	cpsie	i
  return b;
}
 800143c:	bd38      	pop	{r3, r4, r5, pc}
 800143e:	46c0      	nop			; (mov r8, r8)

08001440 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(InputQueue *iqp, uint8_t *bp,
                       size_t n, systime_t time) {
 8001440:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001442:	464e      	mov	r6, r9
 8001444:	4691      	mov	r9, r2
  qnotify_t nfy = iqp->q_notify;
 8001446:	69c2      	ldr	r2, [r0, #28]
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(InputQueue *iqp, uint8_t *bp,
                       size_t n, systime_t time) {
 8001448:	4657      	mov	r7, sl
 800144a:	4645      	mov	r5, r8
 800144c:	b4e0      	push	{r5, r6, r7}
 800144e:	1c04      	adds	r4, r0, #0
 8001450:	468a      	mov	sl, r1
 8001452:	1c1e      	adds	r6, r3, #0
  qnotify_t nfy = iqp->q_notify;
 8001454:	4690      	mov	r8, r2
  size_t r = 0;

  chDbgCheck(n > 0, "chIQReadTimeout");

  chSysLock();
 8001456:	b672      	cpsid	i
 * @api
 */
size_t chIQReadTimeout(InputQueue *iqp, uint8_t *bp,
                       size_t n, systime_t time) {
  qnotify_t nfy = iqp->q_notify;
  size_t r = 0;
 8001458:	2700      	movs	r7, #0

  chDbgCheck(n > 0, "chIQReadTimeout");

  chSysLock();
  while (TRUE) {
    if (nfy)
 800145a:	4643      	mov	r3, r8
 800145c:	2b00      	cmp	r3, #0
 800145e:	d008      	beq.n	8001472 <chIQReadTimeout+0x32>
      nfy(iqp);
 8001460:	1c20      	adds	r0, r4, #0
 8001462:	47c0      	blx	r8
 8001464:	e005      	b.n	8001472 <chIQReadTimeout+0x32>

    while (chIQIsEmptyI(iqp)) {
      if (qwait((GenericQueue *)iqp, time) != Q_OK) {
 8001466:	1c20      	adds	r0, r4, #0
 8001468:	1c31      	adds	r1, r6, #0
 800146a:	f7ff ff79 	bl	8001360 <qwait>
 800146e:	2800      	cmp	r0, #0
 8001470:	d116      	bne.n	80014a0 <chIQReadTimeout+0x60>
  chSysLock();
  while (TRUE) {
    if (nfy)
      nfy(iqp);

    while (chIQIsEmptyI(iqp)) {
 8001472:	68a5      	ldr	r5, [r4, #8]
 8001474:	2d00      	cmp	r5, #0
 8001476:	d0f6      	beq.n	8001466 <chIQReadTimeout+0x26>
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 8001478:	69a3      	ldr	r3, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 800147a:	3d01      	subs	r5, #1
    *bp++ = *iqp->q_rdptr++;
 800147c:	1c5a      	adds	r2, r3, #1
 800147e:	61a2      	str	r2, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8001480:	60a5      	str	r5, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8001482:	781b      	ldrb	r3, [r3, #0]
 8001484:	4652      	mov	r2, sl
 8001486:	55d3      	strb	r3, [r2, r7]
    if (iqp->q_rdptr >= iqp->q_top)
 8001488:	69a3      	ldr	r3, [r4, #24]
 800148a:	6922      	ldr	r2, [r4, #16]
 800148c:	4293      	cmp	r3, r2
 800148e:	d301      	bcc.n	8001494 <chIQReadTimeout+0x54>
      iqp->q_rdptr = iqp->q_buffer;
 8001490:	68e3      	ldr	r3, [r4, #12]
 8001492:	61a3      	str	r3, [r4, #24]

    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 8001494:	b662      	cpsie	i
    r++;
 8001496:	3701      	adds	r7, #1
    if (--n == 0)
 8001498:	45b9      	cmp	r9, r7
 800149a:	d002      	beq.n	80014a2 <chIQReadTimeout+0x62>
      return r;

    chSysLock();
 800149c:	b672      	cpsid	i
  }
 800149e:	e7dc      	b.n	800145a <chIQReadTimeout+0x1a>
    if (nfy)
      nfy(iqp);

    while (chIQIsEmptyI(iqp)) {
      if (qwait((GenericQueue *)iqp, time) != Q_OK) {
        chSysUnlock();
 80014a0:	b662      	cpsie	i
    if (--n == 0)
      return r;

    chSysLock();
  }
}
 80014a2:	1c38      	adds	r0, r7, #0
 80014a4:	bc1c      	pop	{r2, r3, r4}
 80014a6:	4690      	mov	r8, r2
 80014a8:	4699      	mov	r9, r3
 80014aa:	46a2      	mov	sl, r4
 80014ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80014ae:	46c0      	nop			; (mov r8, r8)

080014b0 <chOQInit>:

  queue_init(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer = oqp->q_rdptr = oqp->q_wrptr = bp;
  oqp->q_top = bp + size;
  oqp->q_notify = onfy;
 80014b0:	61c3      	str	r3, [r0, #28]
  oqp->q_link = link;
 80014b2:	9b00      	ldr	r3, [sp, #0]
void chOQInit(OutputQueue *oqp, uint8_t *bp, size_t size, qnotify_t onfy,
              void *link) {

  queue_init(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer = oqp->q_rdptr = oqp->q_wrptr = bp;
 80014b4:	6141      	str	r1, [r0, #20]
 80014b6:	6181      	str	r1, [r0, #24]
 80014b8:	60c1      	str	r1, [r0, #12]
  oqp->q_top = bp + size;
 80014ba:	1889      	adds	r1, r1, r2
 * @init
 */
void chOQInit(OutputQueue *oqp, uint8_t *bp, size_t size, qnotify_t onfy,
              void *link) {

  queue_init(&oqp->q_waiting);
 80014bc:	6040      	str	r0, [r0, #4]
 80014be:	6000      	str	r0, [r0, #0]
  oqp->q_counter = size;
 80014c0:	6082      	str	r2, [r0, #8]
  oqp->q_buffer = oqp->q_rdptr = oqp->q_wrptr = bp;
  oqp->q_top = bp + size;
 80014c2:	6101      	str	r1, [r0, #16]
  oqp->q_notify = onfy;
  oqp->q_link = link;
 80014c4:	6203      	str	r3, [r0, #32]
}
 80014c6:	4770      	bx	lr
 80014c8:	46c0      	nop			; (mov r8, r8)
 80014ca:	46c0      	nop			; (mov r8, r8)
 80014cc:	46c0      	nop			; (mov r8, r8)
 80014ce:	46c0      	nop			; (mov r8, r8)

080014d0 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(OutputQueue *oqp, uint8_t b, systime_t time) {
 80014d0:	b570      	push	{r4, r5, r6, lr}
 80014d2:	1c04      	adds	r4, r0, #0
 80014d4:	1c0e      	adds	r6, r1, #0
 80014d6:	1c15      	adds	r5, r2, #0

  chSysLock();
 80014d8:	b672      	cpsid	i
  while (chOQIsFullI(oqp)) {
 80014da:	e005      	b.n	80014e8 <chOQPutTimeout+0x18>
    msg_t msg;

    if ((msg = qwait((GenericQueue *)oqp, time)) < Q_OK) {
 80014dc:	1c20      	adds	r0, r4, #0
 80014de:	1c29      	adds	r1, r5, #0
 80014e0:	f7ff ff3e 	bl	8001360 <qwait>
 80014e4:	2800      	cmp	r0, #0
 80014e6:	db16      	blt.n	8001516 <chOQPutTimeout+0x46>
 * @api
 */
msg_t chOQPutTimeout(OutputQueue *oqp, uint8_t b, systime_t time) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 80014e8:	68a3      	ldr	r3, [r4, #8]
 80014ea:	2b00      	cmp	r3, #0
 80014ec:	d0f6      	beq.n	80014dc <chOQPutTimeout+0xc>
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 80014ee:	3b01      	subs	r3, #1
 80014f0:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 80014f2:	6963      	ldr	r3, [r4, #20]
 80014f4:	1c5a      	adds	r2, r3, #1
 80014f6:	6162      	str	r2, [r4, #20]
 80014f8:	701e      	strb	r6, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top)
 80014fa:	6962      	ldr	r2, [r4, #20]
 80014fc:	6923      	ldr	r3, [r4, #16]
 80014fe:	429a      	cmp	r2, r3
 8001500:	d301      	bcc.n	8001506 <chOQPutTimeout+0x36>
    oqp->q_wrptr = oqp->q_buffer;
 8001502:	68e2      	ldr	r2, [r4, #12]
 8001504:	6162      	str	r2, [r4, #20]

  if (oqp->q_notify)
 8001506:	69e3      	ldr	r3, [r4, #28]
 8001508:	2b00      	cmp	r3, #0
 800150a:	d001      	beq.n	8001510 <chOQPutTimeout+0x40>
    oqp->q_notify(oqp);
 800150c:	1c20      	adds	r0, r4, #0
 800150e:	4798      	blx	r3

  chSysUnlock();
 8001510:	b662      	cpsie	i
  return Q_OK;
 8001512:	2000      	movs	r0, #0
}
 8001514:	bd70      	pop	{r4, r5, r6, pc}
  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg;

    if ((msg = qwait((GenericQueue *)oqp, time)) < Q_OK) {
      chSysUnlock();
 8001516:	b662      	cpsie	i
      return msg;
 8001518:	e7fc      	b.n	8001514 <chOQPutTimeout+0x44>
 800151a:	46c0      	nop			; (mov r8, r8)
 800151c:	46c0      	nop			; (mov r8, r8)
 800151e:	46c0      	nop			; (mov r8, r8)

08001520 <chOQGetI>:
msg_t chOQGetI(OutputQueue *oqp) {
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp))
 8001520:	6983      	ldr	r3, [r0, #24]
 8001522:	6942      	ldr	r2, [r0, #20]
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(OutputQueue *oqp) {
 8001524:	b510      	push	{r4, lr}
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp))
 8001526:	429a      	cmp	r2, r3
 8001528:	d016      	beq.n	8001558 <chOQGetI+0x38>
 800152a:	6882      	ldr	r2, [r0, #8]
    return Q_EMPTY;

  oqp->q_counter++;
 800152c:	3201      	adds	r2, #1
 800152e:	6082      	str	r2, [r0, #8]
  b = *oqp->q_rdptr++;
 8001530:	1c5a      	adds	r2, r3, #1
 8001532:	6182      	str	r2, [r0, #24]
 8001534:	781c      	ldrb	r4, [r3, #0]
  if (oqp->q_rdptr >= oqp->q_top)
 8001536:	6903      	ldr	r3, [r0, #16]
 8001538:	429a      	cmp	r2, r3
 800153a:	d20a      	bcs.n	8001552 <chOQGetI+0x32>
    oqp->q_rdptr = oqp->q_buffer;

  if (notempty(&oqp->q_waiting))
 800153c:	6802      	ldr	r2, [r0, #0]
 800153e:	4282      	cmp	r2, r0
 8001540:	d005      	beq.n	800154e <chOQGetI+0x2e>
    chSchReadyI(fifo_remove(&oqp->q_waiting))->p_u.rdymsg = Q_OK;
 8001542:	f7ff febd 	bl	80012c0 <fifo_remove>
 8001546:	f7fe ff6b 	bl	8000420 <chSchReadyI>
 800154a:	2300      	movs	r3, #0
 800154c:	6243      	str	r3, [r0, #36]	; 0x24

  return b;
 800154e:	1c20      	adds	r0, r4, #0
}
 8001550:	bd10      	pop	{r4, pc}
    return Q_EMPTY;

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top)
    oqp->q_rdptr = oqp->q_buffer;
 8001552:	68c3      	ldr	r3, [r0, #12]
 8001554:	6183      	str	r3, [r0, #24]
 8001556:	e7f1      	b.n	800153c <chOQGetI+0x1c>
msg_t chOQGetI(OutputQueue *oqp) {
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp))
 8001558:	6882      	ldr	r2, [r0, #8]
 800155a:	2a00      	cmp	r2, #0
 800155c:	d0e6      	beq.n	800152c <chOQGetI+0xc>
    return Q_EMPTY;
 800155e:	2003      	movs	r0, #3
 8001560:	4240      	negs	r0, r0
 8001562:	e7f5      	b.n	8001550 <chOQGetI+0x30>
 8001564:	46c0      	nop			; (mov r8, r8)
 8001566:	46c0      	nop			; (mov r8, r8)
 8001568:	46c0      	nop			; (mov r8, r8)
 800156a:	46c0      	nop			; (mov r8, r8)
 800156c:	46c0      	nop			; (mov r8, r8)
 800156e:	46c0      	nop			; (mov r8, r8)

08001570 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(OutputQueue *oqp, const uint8_t *bp,
                        size_t n, systime_t time) {
 8001570:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001572:	4657      	mov	r7, sl
 8001574:	464e      	mov	r6, r9
 8001576:	4645      	mov	r5, r8
 8001578:	b4e0      	push	{r5, r6, r7}
 800157a:	1c16      	adds	r6, r2, #0
  qnotify_t nfy = oqp->q_notify;
 800157c:	69c2      	ldr	r2, [r0, #28]
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(OutputQueue *oqp, const uint8_t *bp,
                        size_t n, systime_t time) {
 800157e:	1c04      	adds	r4, r0, #0
 8001580:	1c0f      	adds	r7, r1, #0
 8001582:	469a      	mov	sl, r3
  qnotify_t nfy = oqp->q_notify;
 8001584:	4691      	mov	r9, r2
  size_t w = 0;

  chDbgCheck(n > 0, "chOQWriteTimeout");

  chSysLock();
 8001586:	b672      	cpsid	i
 * @api
 */
size_t chOQWriteTimeout(OutputQueue *oqp, const uint8_t *bp,
                        size_t n, systime_t time) {
  qnotify_t nfy = oqp->q_notify;
  size_t w = 0;
 8001588:	2300      	movs	r3, #0
 800158a:	4698      	mov	r8, r3

  chDbgCheck(n > 0, "chOQWriteTimeout");

  chSysLock();
  while (TRUE) {
    while (chOQIsFullI(oqp)) {
 800158c:	68a5      	ldr	r5, [r4, #8]
 800158e:	2d00      	cmp	r5, #0
 8001590:	d01d      	beq.n	80015ce <chOQWriteTimeout+0x5e>
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8001592:	6962      	ldr	r2, [r4, #20]
      if (qwait((GenericQueue *)oqp, time) != Q_OK) {
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
 8001594:	3d01      	subs	r5, #1
    *oqp->q_wrptr++ = *bp++;
 8001596:	1c53      	adds	r3, r2, #1
      if (qwait((GenericQueue *)oqp, time) != Q_OK) {
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
 8001598:	60a5      	str	r5, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 800159a:	6163      	str	r3, [r4, #20]
 800159c:	783b      	ldrb	r3, [r7, #0]
 800159e:	1c7d      	adds	r5, r7, #1
 80015a0:	7013      	strb	r3, [r2, #0]
    if (oqp->q_wrptr >= oqp->q_top)
 80015a2:	6962      	ldr	r2, [r4, #20]
 80015a4:	6923      	ldr	r3, [r4, #16]
 80015a6:	429a      	cmp	r2, r3
 80015a8:	d301      	bcc.n	80015ae <chOQWriteTimeout+0x3e>
      oqp->q_wrptr = oqp->q_buffer;
 80015aa:	68e2      	ldr	r2, [r4, #12]
 80015ac:	6162      	str	r2, [r4, #20]

    if (nfy)
 80015ae:	464b      	mov	r3, r9
 80015b0:	2b00      	cmp	r3, #0
 80015b2:	d001      	beq.n	80015b8 <chOQWriteTimeout+0x48>
      nfy(oqp);
 80015b4:	1c20      	adds	r0, r4, #0
 80015b6:	47c8      	blx	r9

    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 80015b8:	b662      	cpsie	i
    w++;
 80015ba:	2201      	movs	r2, #1
    if (--n == 0)
 80015bc:	3e01      	subs	r6, #1

    if (nfy)
      nfy(oqp);

    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    w++;
 80015be:	4490      	add	r8, r2
    if (--n == 0)
 80015c0:	2e00      	cmp	r6, #0
 80015c2:	d00b      	beq.n	80015dc <chOQWriteTimeout+0x6c>
      return w;
    chSysLock();
 80015c4:	b672      	cpsid	i
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 80015c6:	1c2f      	adds	r7, r5, #0

  chDbgCheck(n > 0, "chOQWriteTimeout");

  chSysLock();
  while (TRUE) {
    while (chOQIsFullI(oqp)) {
 80015c8:	68a5      	ldr	r5, [r4, #8]
 80015ca:	2d00      	cmp	r5, #0
 80015cc:	d1e1      	bne.n	8001592 <chOQWriteTimeout+0x22>
      if (qwait((GenericQueue *)oqp, time) != Q_OK) {
 80015ce:	1c20      	adds	r0, r4, #0
 80015d0:	4651      	mov	r1, sl
 80015d2:	f7ff fec5 	bl	8001360 <qwait>
 80015d6:	2800      	cmp	r0, #0
 80015d8:	d0d8      	beq.n	800158c <chOQWriteTimeout+0x1c>
        chSysUnlock();
 80015da:	b662      	cpsie	i
    w++;
    if (--n == 0)
      return w;
    chSysLock();
  }
}
 80015dc:	4640      	mov	r0, r8
 80015de:	bc1c      	pop	{r2, r3, r4}
 80015e0:	4690      	mov	r8, r2
 80015e2:	4699      	mov	r9, r3
 80015e4:	46a2      	mov	sl, r4
 80015e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80015e8:	46c0      	nop			; (mov r8, r8)
 80015ea:	46c0      	nop			; (mov r8, r8)
 80015ec:	46c0      	nop			; (mov r8, r8)
 80015ee:	46c0      	nop			; (mov r8, r8)
 80015f0:	6e696c62 	.word	0x6e696c62
 80015f4:	3272656b 	.word	0x3272656b
 80015f8:	00000000 	.word	0x00000000
 80015fc:	6e696c62 	.word	0x6e696c62
 8001600:	3172656b 	.word	0x3172656b
	...
 8001610:	656c6469 	.word	0x656c6469
	...

08001620 <vmt>:
 8001620:	080008b1 08000891 080008f1 080008d1     ................
 8001630:	080008e1 080008c1 080008a1 08000881     ................

08001640 <default_config>:
 8001640:	00009600 00000000 00004000 00000000     .........@......

08001650 <_stm32_dma_streams>:
 8001650:	40020008 40020004 00090000 4002001c     ...@...@.......@
 8001660:	40020004 000a0104 40020030 40020004     ...@....0..@...@
 8001670:	000a0208 40020044 40020004 000b030c     ....D..@...@....
 8001680:	40020058 40020004 000b0410 00000000     X..@...@........

08001690 <pal_default_config>:
 8001690:	28000000 00000000 fc000000 65555554     ...(........TUUe
 80016a0:	0000ffff 00000000 00000000 00000000     ................
 80016b0:	00000000 000003f0 55555555 0000ffff     ........UUUU....
	...
 80016c8:	00050000 00000000 f00f0000 05505555     ............UUP.
 80016d8:	0000fcff 00000000 00000000 00000000     ................
	...
 80016f0:	55555555 0000ffff 00000000 00000000     UUUU............
	...
 800170c:	55555550 0000ffff 00000000 00000000     PUUU............
 800171c:	00000000                                ....

08001720 <ch_debug>:
 8001720:	6e69616d 11851600 08480404 1814100c     main......H.....
 8001730:	1e1d1c00 0000201f                       ..... ..
